# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateCreator {
  _avg: CreatorAvgAggregate
  _count: CreatorCountAggregate
  _max: CreatorMaxAggregate
  _min: CreatorMinAggregate
  _sum: CreatorSumAggregate
}

type AggregateDirector {
  _count: DirectorCountAggregate
  _max: DirectorMaxAggregate
  _min: DirectorMinAggregate
}

type AggregateMainUser {
  _avg: MainUserAvgAggregate
  _count: MainUserCountAggregate
  _max: MainUserMaxAggregate
  _min: MainUserMinAggregate
  _sum: MainUserSumAggregate
}

type AggregateMovie {
  _count: MovieCountAggregate
  _max: MovieMaxAggregate
  _min: MovieMinAggregate
}

type AggregateNativeTypeModel {
  _avg: NativeTypeModelAvgAggregate
  _count: NativeTypeModelCountAggregate
  _max: NativeTypeModelMaxAggregate
  _min: NativeTypeModelMinAggregate
  _sum: NativeTypeModelSumAggregate
}

type AggregatePatient {
  _count: PatientCountAggregate
  _max: PatientMaxAggregate
  _min: PatientMinAggregate
}

type AggregateProblem {
  _avg: ProblemAvgAggregate
  _count: ProblemCountAggregate
  _max: ProblemMaxAggregate
  _min: ProblemMinAggregate
  _sum: ProblemSumAggregate
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

input BigIntNullableFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntNullableFilter
  notIn: [BigInt!]
}

input BigIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedBigIntNullableFilter
  _min: NestedBigIntNullableFilter
  _sum: NestedBigIntNullableFilter
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntNullableWithAggregatesFilter
  notIn: [BigInt!]
}

"""The `Byte` scalar type represents byte value as a Buffer"""
scalar Byte

input BytesNullableFilter {
  equals: Byte
  in: [Byte!]
  not: NestedBytesNullableFilter
  notIn: [Byte!]
}

input BytesNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedBytesNullableFilter
  _min: NestedBytesNullableFilter
  equals: Byte
  in: [Byte!]
  not: NestedBytesNullableWithAggregatesFilter
  notIn: [Byte!]
}

type Category {
  name: String!
  number: Int!
  slug: String!
}

type CategoryAvgAggregate {
  number: Float
}

input CategoryAvgOrderByAggregateInput {
  number: SortOrder
}

input CategoryCategoryCompoundUniqueCompoundUniqueInput {
  number: Int!
  slug: String!
}

type CategoryCountAggregate {
  _all: Int!
  name: Int!
  number: Int!
  slug: Int!
}

input CategoryCountOrderByAggregateInput {
  name: SortOrder
  number: SortOrder
  slug: SortOrder
}

type CategoryGroupBy {
  _avg: CategoryAvgAggregate
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
  _sum: CategorySumAggregate
  name: String!
  number: Int!
  slug: String!
}

type CategoryMaxAggregate {
  name: String
  number: Int
  slug: String
}

input CategoryMaxOrderByAggregateInput {
  name: SortOrder
  number: SortOrder
  slug: SortOrder
}

type CategoryMinAggregate {
  name: String
  number: Int
  slug: String
}

input CategoryMinOrderByAggregateInput {
  name: SortOrder
  number: SortOrder
  slug: SortOrder
}

enum CategoryOrderByRelevanceFieldEnum {
  name
  slug
}

input CategoryOrderByRelevanceInput {
  fields: [CategoryOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input CategoryOrderByWithAggregationInput {
  _avg: CategoryAvgOrderByAggregateInput
  _count: CategoryCountOrderByAggregateInput
  _max: CategoryMaxOrderByAggregateInput
  _min: CategoryMinOrderByAggregateInput
  _sum: CategorySumOrderByAggregateInput
  name: SortOrder
  number: SortOrder
  slug: SortOrder
}

input CategoryOrderByWithRelationAndSearchRelevanceInput {
  _relevance: CategoryOrderByRelevanceInput
  name: SortOrder
  number: SortOrder
  slug: SortOrder
}

enum CategoryScalarFieldEnum {
  name
  number
  slug
}

input CategoryScalarWhereWithAggregatesInput {
  AND: [CategoryScalarWhereWithAggregatesInput!]
  NOT: [CategoryScalarWhereWithAggregatesInput!]
  OR: [CategoryScalarWhereWithAggregatesInput!]
  name: StringWithAggregatesFilter
  number: IntWithAggregatesFilter
  slug: StringWithAggregatesFilter
}

type CategorySumAggregate {
  number: Int
}

input CategorySumOrderByAggregateInput {
  number: SortOrder
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  name: StringFilter
  number: IntFilter
  slug: StringFilter
}

input CategoryWhereUniqueInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  categoryCompoundUnique: CategoryCategoryCompoundUniqueCompoundUniqueInput
  name: StringFilter
  number: IntFilter
  slug: StringFilter
}

type Creator {
  _count: CreatorCount
  id: ID!
  likes(cursor: ProblemWhereUniqueInput, distinct: [ProblemScalarFieldEnum!], orderBy: [ProblemOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ProblemWhereInput): [Problem!]!
  name: String!
  problems(cursor: ProblemWhereUniqueInput, distinct: [ProblemScalarFieldEnum!], orderBy: [ProblemOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ProblemWhereInput): [Problem!]!
}

type CreatorAvgAggregate {
  id: Float
}

input CreatorAvgOrderByAggregateInput {
  id: SortOrder
}

type CreatorCount {
  likes(where: ProblemWhereInput): Int!
  problems(where: ProblemWhereInput): Int!
}

type CreatorCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input CreatorCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input CreatorCreateInput {
  likes: ProblemCreateNestedManyWithoutLikedByInput
  name: String!
  problems: ProblemCreateNestedManyWithoutCreatorInput
}

input CreatorCreateManyInput {
  id: Int
  name: String!
}

input CreatorCreateNestedManyWithoutLikesInput {
  connect: [CreatorWhereUniqueInput!]
  connectOrCreate: [CreatorCreateOrConnectWithoutLikesInput!]
  create: [CreatorCreateWithoutLikesInput!]
}

input CreatorCreateNestedOneWithoutProblemsInput {
  connect: CreatorWhereUniqueInput
  connectOrCreate: CreatorCreateOrConnectWithoutProblemsInput
  create: CreatorCreateWithoutProblemsInput
}

input CreatorCreateOrConnectWithoutLikesInput {
  create: CreatorCreateWithoutLikesInput!
  where: CreatorWhereUniqueInput!
}

input CreatorCreateOrConnectWithoutProblemsInput {
  create: CreatorCreateWithoutProblemsInput!
  where: CreatorWhereUniqueInput!
}

input CreatorCreateWithoutLikesInput {
  name: String!
  problems: ProblemCreateNestedManyWithoutCreatorInput
}

input CreatorCreateWithoutProblemsInput {
  likes: ProblemCreateNestedManyWithoutLikedByInput
  name: String!
}

type CreatorGroupBy {
  _avg: CreatorAvgAggregate
  _count: CreatorCountAggregate
  _max: CreatorMaxAggregate
  _min: CreatorMinAggregate
  _sum: CreatorSumAggregate
  id: Int!
  name: String!
}

input CreatorListRelationFilter {
  every: CreatorWhereInput
  none: CreatorWhereInput
  some: CreatorWhereInput
}

type CreatorMaxAggregate {
  id: Int
  name: String
}

input CreatorMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type CreatorMinAggregate {
  id: Int
  name: String
}

input CreatorMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input CreatorOrderByRelationAggregateInput {
  _count: SortOrder
}

enum CreatorOrderByRelevanceFieldEnum {
  name
}

input CreatorOrderByRelevanceInput {
  fields: [CreatorOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input CreatorOrderByWithAggregationInput {
  _avg: CreatorAvgOrderByAggregateInput
  _count: CreatorCountOrderByAggregateInput
  _max: CreatorMaxOrderByAggregateInput
  _min: CreatorMinOrderByAggregateInput
  _sum: CreatorSumOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input CreatorOrderByWithRelationAndSearchRelevanceInput {
  _relevance: CreatorOrderByRelevanceInput
  id: SortOrder
  likes: ProblemOrderByRelationAggregateInput
  name: SortOrder
  problems: ProblemOrderByRelationAggregateInput
}

input CreatorRelationFilter {
  is: CreatorWhereInput
  isNot: CreatorWhereInput
}

enum CreatorScalarFieldEnum {
  id
  name
}

input CreatorScalarWhereInput {
  AND: [CreatorScalarWhereInput!]
  NOT: [CreatorScalarWhereInput!]
  OR: [CreatorScalarWhereInput!]
  id: IntFilter
  name: StringFilter
}

input CreatorScalarWhereWithAggregatesInput {
  AND: [CreatorScalarWhereWithAggregatesInput!]
  NOT: [CreatorScalarWhereWithAggregatesInput!]
  OR: [CreatorScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type CreatorSumAggregate {
  id: Int
}

input CreatorSumOrderByAggregateInput {
  id: SortOrder
}

input CreatorUpdateInput {
  likes: ProblemUpdateManyWithoutLikedByNestedInput
  name: String
  problems: ProblemUpdateManyWithoutCreatorNestedInput
}

input CreatorUpdateManyMutationInput {
  name: String
}

input CreatorUpdateManyWithWhereWithoutLikesInput {
  data: CreatorUpdateManyMutationInput!
  where: CreatorScalarWhereInput!
}

input CreatorUpdateManyWithoutLikesNestedInput {
  connect: [CreatorWhereUniqueInput!]
  connectOrCreate: [CreatorCreateOrConnectWithoutLikesInput!]
  create: [CreatorCreateWithoutLikesInput!]
  delete: [CreatorWhereUniqueInput!]
  deleteMany: [CreatorScalarWhereInput!]
  disconnect: [CreatorWhereUniqueInput!]
  set: [CreatorWhereUniqueInput!]
  update: [CreatorUpdateWithWhereUniqueWithoutLikesInput!]
  updateMany: [CreatorUpdateManyWithWhereWithoutLikesInput!]
  upsert: [CreatorUpsertWithWhereUniqueWithoutLikesInput!]
}

input CreatorUpdateOneWithoutProblemsNestedInput {
  connect: CreatorWhereUniqueInput
  connectOrCreate: CreatorCreateOrConnectWithoutProblemsInput
  create: CreatorCreateWithoutProblemsInput
  delete: CreatorWhereInput
  disconnect: CreatorWhereInput
  update: CreatorUpdateToOneWithWhereWithoutProblemsInput
  upsert: CreatorUpsertWithoutProblemsInput
}

input CreatorUpdateToOneWithWhereWithoutProblemsInput {
  data: CreatorUpdateWithoutProblemsInput!
  where: CreatorWhereInput
}

input CreatorUpdateWithWhereUniqueWithoutLikesInput {
  data: CreatorUpdateWithoutLikesInput!
  where: CreatorWhereUniqueInput!
}

input CreatorUpdateWithoutLikesInput {
  name: String
  problems: ProblemUpdateManyWithoutCreatorNestedInput
}

input CreatorUpdateWithoutProblemsInput {
  likes: ProblemUpdateManyWithoutLikedByNestedInput
  name: String
}

input CreatorUpsertWithWhereUniqueWithoutLikesInput {
  create: CreatorCreateWithoutLikesInput!
  update: CreatorUpdateWithoutLikesInput!
  where: CreatorWhereUniqueInput!
}

input CreatorUpsertWithoutProblemsInput {
  create: CreatorCreateWithoutProblemsInput!
  update: CreatorUpdateWithoutProblemsInput!
  where: CreatorWhereInput
}

input CreatorWhereInput {
  AND: [CreatorWhereInput!]
  NOT: [CreatorWhereInput!]
  OR: [CreatorWhereInput!]
  id: IntFilter
  likes: ProblemListRelationFilter
  name: StringFilter
  problems: ProblemListRelationFilter
}

input CreatorWhereUniqueInput {
  AND: [CreatorWhereInput!]
  NOT: [CreatorWhereInput!]
  OR: [CreatorWhereInput!]
  id: Int
  likes: ProblemListRelationFilter
  name: StringFilter
  problems: ProblemListRelationFilter
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

"""
GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library.
"""
scalar Decimal

input DecimalNullableFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableFilter
  notIn: [Decimal!]
}

input DecimalNullableWithAggregatesFilter {
  _avg: NestedDecimalNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedDecimalNullableFilter
  _min: NestedDecimalNullableFilter
  _sum: NestedDecimalNullableFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableWithAggregatesFilter
  notIn: [Decimal!]
}

type Director {
  _count: DirectorCount
  firstName: String!
  lastName: String!
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
}

type DirectorCount {
  movies(where: MovieWhereInput): Int!
}

type DirectorCountAggregate {
  _all: Int!
  firstName: Int!
  lastName: Int!
}

input DirectorCountOrderByAggregateInput {
  firstName: SortOrder
  lastName: SortOrder
}

input DirectorCreateInput {
  firstName: String!
  lastName: String!
  movies: MovieCreateNestedManyWithoutDirectorInput
}

input DirectorCreateManyInput {
  firstName: String!
  lastName: String!
}

input DirectorCreateNestedOneWithoutMoviesInput {
  connect: DirectorWhereUniqueInput
  connectOrCreate: DirectorCreateOrConnectWithoutMoviesInput
  create: DirectorCreateWithoutMoviesInput
}

input DirectorCreateOrConnectWithoutMoviesInput {
  create: DirectorCreateWithoutMoviesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorCreateWithoutMoviesInput {
  firstName: String!
  lastName: String!
}

input DirectorFirstNameLastNameCompoundUniqueInput {
  firstName: String!
  lastName: String!
}

type DirectorGroupBy {
  _count: DirectorCountAggregate
  _max: DirectorMaxAggregate
  _min: DirectorMinAggregate
  firstName: String!
  lastName: String!
}

type DirectorMaxAggregate {
  firstName: String
  lastName: String
}

input DirectorMaxOrderByAggregateInput {
  firstName: SortOrder
  lastName: SortOrder
}

type DirectorMinAggregate {
  firstName: String
  lastName: String
}

input DirectorMinOrderByAggregateInput {
  firstName: SortOrder
  lastName: SortOrder
}

enum DirectorOrderByRelevanceFieldEnum {
  firstName
  lastName
}

input DirectorOrderByRelevanceInput {
  fields: [DirectorOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input DirectorOrderByWithAggregationInput {
  _count: DirectorCountOrderByAggregateInput
  _max: DirectorMaxOrderByAggregateInput
  _min: DirectorMinOrderByAggregateInput
  firstName: SortOrder
  lastName: SortOrder
}

input DirectorOrderByWithRelationAndSearchRelevanceInput {
  _relevance: DirectorOrderByRelevanceInput
  firstName: SortOrder
  lastName: SortOrder
  movies: MovieOrderByRelationAggregateInput
}

input DirectorRelationFilter {
  is: DirectorWhereInput
  isNot: DirectorWhereInput
}

enum DirectorScalarFieldEnum {
  firstName
  lastName
}

input DirectorScalarWhereWithAggregatesInput {
  AND: [DirectorScalarWhereWithAggregatesInput!]
  NOT: [DirectorScalarWhereWithAggregatesInput!]
  OR: [DirectorScalarWhereWithAggregatesInput!]
  firstName: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
}

input DirectorUpdateInput {
  firstName: String
  lastName: String
  movies: MovieUpdateManyWithoutDirectorNestedInput
}

input DirectorUpdateManyMutationInput {
  firstName: String
  lastName: String
}

input DirectorUpdateOneRequiredWithoutMoviesNestedInput {
  connect: DirectorWhereUniqueInput
  connectOrCreate: DirectorCreateOrConnectWithoutMoviesInput
  create: DirectorCreateWithoutMoviesInput
  update: DirectorUpdateToOneWithWhereWithoutMoviesInput
  upsert: DirectorUpsertWithoutMoviesInput
}

input DirectorUpdateToOneWithWhereWithoutMoviesInput {
  data: DirectorUpdateWithoutMoviesInput!
  where: DirectorWhereInput
}

input DirectorUpdateWithoutMoviesInput {
  firstName: String
  lastName: String
}

input DirectorUpsertWithoutMoviesInput {
  create: DirectorCreateWithoutMoviesInput!
  update: DirectorUpdateWithoutMoviesInput!
  where: DirectorWhereInput
}

input DirectorWhereInput {
  AND: [DirectorWhereInput!]
  NOT: [DirectorWhereInput!]
  OR: [DirectorWhereInput!]
  firstName: StringFilter
  lastName: StringFilter
  movies: MovieListRelationFilter
}

input DirectorWhereUniqueInput {
  AND: [DirectorWhereInput!]
  NOT: [DirectorWhereInput!]
  OR: [DirectorWhereInput!]
  firstName: StringFilter
  firstName_lastName: DirectorFirstNameLastNameCompoundUniqueInput
  lastName: StringFilter
  movies: MovieListRelationFilter
}

input EnumPostKindNullableFilter {
  equals: PostKind
  in: [PostKind!]
  not: NestedEnumPostKindNullableFilter
  notIn: [PostKind!]
}

input EnumPostKindNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedEnumPostKindNullableFilter
  _min: NestedEnumPostKindNullableFilter
  equals: PostKind
  in: [PostKind!]
  not: NestedEnumPostKindNullableWithAggregatesFilter
  notIn: [PostKind!]
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableListFilter {
  equals: [Int!]
  has: Int
  hasEvery: [Int!]
  hasSome: [Int!]
  isEmpty: Boolean
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedJsonFilter
  _min: NestedJsonFilter
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

"""User model doc"""
type MainUser {
  _count: MainUserCount
  accountBalance: Float!
  age: Int!
  aliases: [String!]!
  amount: Float!
  clientPosts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  email: String!

  """renamed field doc"""
  firstName: String
  grades: [Int!]!
  hello: String!

  """User model field doc"""
  id: ID!
  role: Role!
}

type MainUserAvgAggregate {
  age: Float
  amount: Float
  balance: Float
  grades: Float
  id: Float
}

input MainUserAvgOrderByAggregateInput {
  accountBalance: SortOrder
  age: SortOrder
  amount: SortOrder
  grades: SortOrder
  id: SortOrder
}

type MainUserCount {
  editorPosts(where: PostWhereInput): Int!
  posts(where: PostWhereInput): Int!
}

type MainUserCountAggregate {
  _all: Int!
  age: Int!
  aliases: Int!
  amount: Int!
  balance: Int!
  email: Int!
  grades: Int!
  id: Int!
  name: Int!
  role: Int!
}

input MainUserCountOrderByAggregateInput {
  accountBalance: SortOrder
  age: SortOrder
  aliases: SortOrder
  amount: SortOrder
  email: SortOrder
  firstName: SortOrder
  grades: SortOrder
  id: SortOrder
  role: SortOrder
}

input MainUserCreateInput {
  accountBalance: Float!
  age: Int!
  aliases: [String!]
  amount: Float!
  clientPosts: PostCreateNestedManyWithoutAuthorInput
  editorPosts: PostCreateNestedManyWithoutEditorInput
  email: String!
  firstName: String
  grades: [Int!]
  role: Role!
}

input MainUserCreateManyInput {
  accountBalance: Float!
  age: Int!
  aliases: [String!]
  amount: Float!
  email: String!
  firstName: String
  grades: [Int!]
  id: Int
  role: Role!
}

input MainUserCreateNestedOneWithoutEditorPostsInput {
  connect: MainUserWhereUniqueInput
  connectOrCreate: MainUserCreateOrConnectWithoutEditorPostsInput
  create: MainUserCreateWithoutEditorPostsInput
}

input MainUserCreateNestedOneWithoutPostsInput {
  connect: MainUserWhereUniqueInput
  connectOrCreate: MainUserCreateOrConnectWithoutPostsInput
  create: MainUserCreateWithoutPostsInput
}

input MainUserCreateOrConnectWithoutEditorPostsInput {
  create: MainUserCreateWithoutEditorPostsInput!
  where: MainUserWhereUniqueInput!
}

input MainUserCreateOrConnectWithoutPostsInput {
  create: MainUserCreateWithoutPostsInput!
  where: MainUserWhereUniqueInput!
}

input MainUserCreateWithoutEditorPostsInput {
  accountBalance: Float!
  age: Int!
  aliases: [String!]
  amount: Float!
  clientPosts: PostCreateNestedManyWithoutAuthorInput
  email: String!
  firstName: String
  grades: [Int!]
  role: Role!
}

input MainUserCreateWithoutPostsInput {
  accountBalance: Float!
  age: Int!
  aliases: [String!]
  amount: Float!
  editorPosts: PostCreateNestedManyWithoutEditorInput
  email: String!
  firstName: String
  grades: [Int!]
  role: Role!
}

type MainUserGroupBy {
  _avg: MainUserAvgAggregate
  _count: MainUserCountAggregate
  _max: MainUserMaxAggregate
  _min: MainUserMinAggregate
  _sum: MainUserSumAggregate
  age: Int!
  aliases: [String!]
  amount: Float!
  balance: Float!
  email: String!
  grades: [Int!]
  id: Int!
  name: String
  role: Role!
}

type MainUserMaxAggregate {
  age: Int
  amount: Float
  balance: Float
  email: String
  id: Int
  name: String
  role: Role
}

input MainUserMaxOrderByAggregateInput {
  accountBalance: SortOrder
  age: SortOrder
  amount: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  role: SortOrder
}

type MainUserMinAggregate {
  age: Int
  amount: Float
  balance: Float
  email: String
  id: Int
  name: String
  role: Role
}

input MainUserMinOrderByAggregateInput {
  accountBalance: SortOrder
  age: SortOrder
  amount: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  role: SortOrder
}

enum MainUserOrderByRelevanceFieldEnum {
  aliases
  email
  firstName
}

input MainUserOrderByRelevanceInput {
  fields: [MainUserOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input MainUserOrderByWithAggregationInput {
  _avg: MainUserAvgOrderByAggregateInput
  _count: MainUserCountOrderByAggregateInput
  _max: MainUserMaxOrderByAggregateInput
  _min: MainUserMinOrderByAggregateInput
  _sum: MainUserSumOrderByAggregateInput
  accountBalance: SortOrder
  age: SortOrder
  aliases: SortOrder
  amount: SortOrder
  email: SortOrder
  firstName: SortOrderInput
  grades: SortOrder
  id: SortOrder
  role: SortOrder
}

input MainUserOrderByWithRelationAndSearchRelevanceInput {
  _relevance: MainUserOrderByRelevanceInput
  accountBalance: SortOrder
  age: SortOrder
  aliases: SortOrder
  amount: SortOrder
  clientPosts: PostOrderByRelationAggregateInput
  editorPosts: PostOrderByRelationAggregateInput
  email: SortOrder
  firstName: SortOrderInput
  grades: SortOrder
  id: SortOrder
  role: SortOrder
}

input MainUserRelationFilter {
  is: MainUserWhereInput
  isNot: MainUserWhereInput
}

enum MainUserScalarFieldEnum {
  accountBalance
  age
  aliases
  amount
  email
  firstName
  grades
  id
  role
}

input MainUserScalarWhereWithAggregatesInput {
  AND: [MainUserScalarWhereWithAggregatesInput!]
  NOT: [MainUserScalarWhereWithAggregatesInput!]
  OR: [MainUserScalarWhereWithAggregatesInput!]
  accountBalance: FloatWithAggregatesFilter
  age: IntWithAggregatesFilter
  aliases: StringNullableListFilter
  amount: FloatWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringNullableWithAggregatesFilter
  grades: IntNullableListFilter
  id: IntWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
}

type MainUserSumAggregate {
  age: Int
  amount: Float
  balance: Float
  grades: [Int!]
  id: Int
}

input MainUserSumOrderByAggregateInput {
  accountBalance: SortOrder
  age: SortOrder
  amount: SortOrder
  grades: SortOrder
  id: SortOrder
}

input MainUserUpdateInput {
  accountBalance: Float
  age: Int
  aliases: [String!]
  amount: Float
  clientPosts: PostUpdateManyWithoutAuthorNestedInput
  editorPosts: PostUpdateManyWithoutEditorNestedInput
  email: String
  firstName: String
  grades: [Int!]
  role: Role
}

input MainUserUpdateManyMutationInput {
  accountBalance: Float
  age: Int
  aliases: [String!]
  amount: Float
  email: String
  firstName: String
  grades: [Int!]
  role: Role
}

input MainUserUpdateOneRequiredWithoutPostsNestedInput {
  connect: MainUserWhereUniqueInput
  connectOrCreate: MainUserCreateOrConnectWithoutPostsInput
  create: MainUserCreateWithoutPostsInput
  update: MainUserUpdateToOneWithWhereWithoutPostsInput
  upsert: MainUserUpsertWithoutPostsInput
}

input MainUserUpdateOneWithoutEditorPostsNestedInput {
  connect: MainUserWhereUniqueInput
  connectOrCreate: MainUserCreateOrConnectWithoutEditorPostsInput
  create: MainUserCreateWithoutEditorPostsInput
  delete: MainUserWhereInput
  disconnect: MainUserWhereInput
  update: MainUserUpdateToOneWithWhereWithoutEditorPostsInput
  upsert: MainUserUpsertWithoutEditorPostsInput
}

input MainUserUpdateToOneWithWhereWithoutEditorPostsInput {
  data: MainUserUpdateWithoutEditorPostsInput!
  where: MainUserWhereInput
}

input MainUserUpdateToOneWithWhereWithoutPostsInput {
  data: MainUserUpdateWithoutPostsInput!
  where: MainUserWhereInput
}

input MainUserUpdateWithoutEditorPostsInput {
  accountBalance: Float
  age: Int
  aliases: [String!]
  amount: Float
  clientPosts: PostUpdateManyWithoutAuthorNestedInput
  email: String
  firstName: String
  grades: [Int!]
  role: Role
}

input MainUserUpdateWithoutPostsInput {
  accountBalance: Float
  age: Int
  aliases: [String!]
  amount: Float
  editorPosts: PostUpdateManyWithoutEditorNestedInput
  email: String
  firstName: String
  grades: [Int!]
  role: Role
}

input MainUserUpsertWithoutEditorPostsInput {
  create: MainUserCreateWithoutEditorPostsInput!
  update: MainUserUpdateWithoutEditorPostsInput!
  where: MainUserWhereInput
}

input MainUserUpsertWithoutPostsInput {
  create: MainUserCreateWithoutPostsInput!
  update: MainUserUpdateWithoutPostsInput!
  where: MainUserWhereInput
}

input MainUserWhereInput {
  AND: [MainUserWhereInput!]
  NOT: [MainUserWhereInput!]
  OR: [MainUserWhereInput!]
  accountBalance: FloatFilter
  age: IntFilter
  aliases: StringNullableListFilter
  amount: FloatFilter
  clientPosts: PostListRelationFilter
  editorPosts: PostListRelationFilter
  email: StringFilter
  firstName: StringNullableFilter
  grades: IntNullableListFilter
  id: IntFilter
  role: EnumRoleFilter
}

input MainUserWhereUniqueInput {
  AND: [MainUserWhereInput!]
  NOT: [MainUserWhereInput!]
  OR: [MainUserWhereInput!]
  accountBalance: FloatFilter
  age: IntFilter
  aliases: StringNullableListFilter
  amount: FloatFilter
  clientPosts: PostListRelationFilter
  editorPosts: PostListRelationFilter
  email: String
  firstName: StringNullableFilter
  grades: IntNullableListFilter
  id: Int
  role: EnumRoleFilter
}

type Movie {
  director: Director!
  directorFirstName: String!
  directorLastName: String!
  title: String!
}

type MovieCountAggregate {
  _all: Int!
  directorFirstName: Int!
  directorLastName: Int!
  title: Int!
}

input MovieCountOrderByAggregateInput {
  directorFirstName: SortOrder
  directorLastName: SortOrder
  title: SortOrder
}

input MovieCreateInput {
  director: DirectorCreateNestedOneWithoutMoviesInput!
  title: String!
}

input MovieCreateManyDirectorInput {
  title: String!
}

input MovieCreateManyDirectorInputEnvelope {
  data: [MovieCreateManyDirectorInput!]!
  skipDuplicates: Boolean
}

input MovieCreateManyInput {
  directorFirstName: String!
  directorLastName: String!
  title: String!
}

input MovieCreateNestedManyWithoutDirectorInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutDirectorInput!]
  create: [MovieCreateWithoutDirectorInput!]
  createMany: MovieCreateManyDirectorInputEnvelope
}

input MovieCreateOrConnectWithoutDirectorInput {
  create: MovieCreateWithoutDirectorInput!
  where: MovieWhereUniqueInput!
}

input MovieCreateWithoutDirectorInput {
  title: String!
}

type MovieGroupBy {
  _count: MovieCountAggregate
  _max: MovieMaxAggregate
  _min: MovieMinAggregate
  directorFirstName: String!
  directorLastName: String!
  title: String!
}

input MovieListRelationFilter {
  every: MovieWhereInput
  none: MovieWhereInput
  some: MovieWhereInput
}

type MovieMaxAggregate {
  directorFirstName: String
  directorLastName: String
  title: String
}

input MovieMaxOrderByAggregateInput {
  directorFirstName: SortOrder
  directorLastName: SortOrder
  title: SortOrder
}

type MovieMinAggregate {
  directorFirstName: String
  directorLastName: String
  title: String
}

input MovieMinOrderByAggregateInput {
  directorFirstName: SortOrder
  directorLastName: SortOrder
  title: SortOrder
}

input MovieMovieCompoundIdCompoundUniqueInput {
  directorFirstName: String!
  directorLastName: String!
  title: String!
}

input MovieOrderByRelationAggregateInput {
  _count: SortOrder
}

enum MovieOrderByRelevanceFieldEnum {
  directorFirstName
  directorLastName
  title
}

input MovieOrderByRelevanceInput {
  fields: [MovieOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input MovieOrderByWithAggregationInput {
  _count: MovieCountOrderByAggregateInput
  _max: MovieMaxOrderByAggregateInput
  _min: MovieMinOrderByAggregateInput
  directorFirstName: SortOrder
  directorLastName: SortOrder
  title: SortOrder
}

input MovieOrderByWithRelationAndSearchRelevanceInput {
  _relevance: MovieOrderByRelevanceInput
  director: DirectorOrderByWithRelationAndSearchRelevanceInput
  directorFirstName: SortOrder
  directorLastName: SortOrder
  title: SortOrder
}

enum MovieScalarFieldEnum {
  directorFirstName
  directorLastName
  title
}

input MovieScalarWhereInput {
  AND: [MovieScalarWhereInput!]
  NOT: [MovieScalarWhereInput!]
  OR: [MovieScalarWhereInput!]
  directorFirstName: StringFilter
  directorLastName: StringFilter
  title: StringFilter
}

input MovieScalarWhereWithAggregatesInput {
  AND: [MovieScalarWhereWithAggregatesInput!]
  NOT: [MovieScalarWhereWithAggregatesInput!]
  OR: [MovieScalarWhereWithAggregatesInput!]
  directorFirstName: StringWithAggregatesFilter
  directorLastName: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
}

input MovieUpdateInput {
  director: DirectorUpdateOneRequiredWithoutMoviesNestedInput
  title: String
}

input MovieUpdateManyMutationInput {
  title: String
}

input MovieUpdateManyWithWhereWithoutDirectorInput {
  data: MovieUpdateManyMutationInput!
  where: MovieScalarWhereInput!
}

input MovieUpdateManyWithoutDirectorNestedInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutDirectorInput!]
  create: [MovieCreateWithoutDirectorInput!]
  createMany: MovieCreateManyDirectorInputEnvelope
  delete: [MovieWhereUniqueInput!]
  deleteMany: [MovieScalarWhereInput!]
  disconnect: [MovieWhereUniqueInput!]
  set: [MovieWhereUniqueInput!]
  update: [MovieUpdateWithWhereUniqueWithoutDirectorInput!]
  updateMany: [MovieUpdateManyWithWhereWithoutDirectorInput!]
  upsert: [MovieUpsertWithWhereUniqueWithoutDirectorInput!]
}

input MovieUpdateWithWhereUniqueWithoutDirectorInput {
  data: MovieUpdateWithoutDirectorInput!
  where: MovieWhereUniqueInput!
}

input MovieUpdateWithoutDirectorInput {
  title: String
}

input MovieUpsertWithWhereUniqueWithoutDirectorInput {
  create: MovieCreateWithoutDirectorInput!
  update: MovieUpdateWithoutDirectorInput!
  where: MovieWhereUniqueInput!
}

input MovieWhereInput {
  AND: [MovieWhereInput!]
  NOT: [MovieWhereInput!]
  OR: [MovieWhereInput!]
  director: DirectorRelationFilter
  directorFirstName: StringFilter
  directorLastName: StringFilter
  title: StringFilter
}

input MovieWhereUniqueInput {
  AND: [MovieWhereInput!]
  NOT: [MovieWhereInput!]
  OR: [MovieWhereInput!]
  director: DirectorRelationFilter
  directorFirstName: StringFilter
  directorLastName: StringFilter
  movieCompoundId: MovieMovieCompoundIdCompoundUniqueInput
  title: StringFilter
}

type Mutation {
  createManyCreator(data: [CreatorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyDirector(data: [DirectorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMainUser(data: [MainUserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMovie(data: [MovieCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyNativeTypeModel(data: [NativeTypeModelCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPatient(data: [PatientCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyProblem(data: [ProblemCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneCreator(data: CreatorCreateInput!): Creator!
  createOneDirector(data: DirectorCreateInput!): Director!
  createOneMainUser(data: MainUserCreateInput!): MainUser!
  createOneMovie(data: MovieCreateInput!): Movie!
  createOneNativeTypeModel(data: NativeTypeModelCreateInput!): NativeTypeModel!
  createOnePatient(data: PatientCreateInput!): Patient!
  createOnePost(data: PostCreateInput!): Post!
  createOneProblem(data: ProblemCreateInput!): Problem!
  customCreatePost(data: PostCreateInput!): Post!
  deleteManyCreator(where: CreatorWhereInput): AffectedRowsOutput!
  deleteManyDirector(where: DirectorWhereInput): AffectedRowsOutput!
  deleteManyMainUser(where: MainUserWhereInput): AffectedRowsOutput!
  deleteManyMovie(where: MovieWhereInput): AffectedRowsOutput!
  deleteManyNativeTypeModel(where: NativeTypeModelWhereInput): AffectedRowsOutput!
  deleteManyPatient(where: PatientWhereInput): AffectedRowsOutput!
  deleteManyProblem(where: ProblemWhereInput): AffectedRowsOutput!
  deleteOneCreator(where: CreatorWhereUniqueInput!): Creator
  deleteOneDirector(where: DirectorWhereUniqueInput!): Director
  deleteOneMainUser(where: MainUserWhereUniqueInput!): MainUser
  deleteOneMovie(where: MovieWhereUniqueInput!): Movie
  deleteOneNativeTypeModel(where: NativeTypeModelWhereUniqueInput!): NativeTypeModel
  deleteOnePatient(where: PatientWhereUniqueInput!): Patient
  deleteOneProblem(where: ProblemWhereUniqueInput!): Problem
  updateManyCreator(data: CreatorUpdateManyMutationInput!, where: CreatorWhereInput): AffectedRowsOutput!
  updateManyDirector(data: DirectorUpdateManyMutationInput!, where: DirectorWhereInput): AffectedRowsOutput!
  updateManyMainUser(data: MainUserUpdateManyMutationInput!, where: MainUserWhereInput): AffectedRowsOutput!
  updateManyMovie(data: MovieUpdateManyMutationInput!, where: MovieWhereInput): AffectedRowsOutput!
  updateManyNativeTypeModel(data: NativeTypeModelUpdateManyMutationInput!, where: NativeTypeModelWhereInput): AffectedRowsOutput!
  updateManyPatient(data: PatientUpdateManyMutationInput!, where: PatientWhereInput): AffectedRowsOutput!
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): AffectedRowsOutput!
  updateManyProblem(data: ProblemUpdateManyMutationInput!, where: ProblemWhereInput): AffectedRowsOutput!
  updateOneCreator(data: CreatorUpdateInput!, where: CreatorWhereUniqueInput!): Creator
  updateOneDirector(data: DirectorUpdateInput!, where: DirectorWhereUniqueInput!): Director
  updateOneMainUser(data: MainUserUpdateInput!, where: MainUserWhereUniqueInput!): MainUser
  updateOneMovie(data: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie
  updateOneNativeTypeModel(data: NativeTypeModelUpdateInput!, where: NativeTypeModelWhereUniqueInput!): NativeTypeModel
  updateOnePatient(data: PatientUpdateInput!, where: PatientWhereUniqueInput!): Patient
  updateOneProblem(data: ProblemUpdateInput!, where: ProblemWhereUniqueInput!): Problem
  upsertOneCreator(create: CreatorCreateInput!, update: CreatorUpdateInput!, where: CreatorWhereUniqueInput!): Creator!
  upsertOneDirector(create: DirectorCreateInput!, update: DirectorUpdateInput!, where: DirectorWhereUniqueInput!): Director!
  upsertOneMainUser(create: MainUserCreateInput!, update: MainUserUpdateInput!, where: MainUserWhereUniqueInput!): MainUser!
  upsertOneMovie(create: MovieCreateInput!, update: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie!
  upsertOneNativeTypeModel(create: NativeTypeModelCreateInput!, update: NativeTypeModelUpdateInput!, where: NativeTypeModelWhereUniqueInput!): NativeTypeModel!
  upsertOnePatient(create: PatientCreateInput!, update: PatientUpdateInput!, where: PatientWhereUniqueInput!): Patient!
  upsertOneProblem(create: ProblemCreateInput!, update: ProblemUpdateInput!, where: ProblemWhereUniqueInput!): Problem!
}

type NativeTypeModel {
  bigInt: BigInt
  byteA: Byte
  decimal: Decimal
  id: ID!
}

type NativeTypeModelAvgAggregate {
  bigInt: Float
  decimal: Decimal
  id: Float
}

input NativeTypeModelAvgOrderByAggregateInput {
  bigInt: SortOrder
  decimal: SortOrder
  id: SortOrder
}

type NativeTypeModelCountAggregate {
  _all: Int!
  bigInt: Int!
  byteA: Int!
  decimal: Int!
  id: Int!
}

input NativeTypeModelCountOrderByAggregateInput {
  bigInt: SortOrder
  byteA: SortOrder
  decimal: SortOrder
  id: SortOrder
}

input NativeTypeModelCreateInput {
  bigInt: BigInt
  byteA: Byte
  decimal: Decimal
}

input NativeTypeModelCreateManyInput {
  bigInt: BigInt
  byteA: Byte
  decimal: Decimal
  id: Int
}

type NativeTypeModelGroupBy {
  _avg: NativeTypeModelAvgAggregate
  _count: NativeTypeModelCountAggregate
  _max: NativeTypeModelMaxAggregate
  _min: NativeTypeModelMinAggregate
  _sum: NativeTypeModelSumAggregate
  bigInt: BigInt
  byteA: Byte
  decimal: Decimal
  id: Int!
}

type NativeTypeModelMaxAggregate {
  bigInt: BigInt
  byteA: Byte
  decimal: Decimal
  id: Int
}

input NativeTypeModelMaxOrderByAggregateInput {
  bigInt: SortOrder
  byteA: SortOrder
  decimal: SortOrder
  id: SortOrder
}

type NativeTypeModelMinAggregate {
  bigInt: BigInt
  byteA: Byte
  decimal: Decimal
  id: Int
}

input NativeTypeModelMinOrderByAggregateInput {
  bigInt: SortOrder
  byteA: SortOrder
  decimal: SortOrder
  id: SortOrder
}

input NativeTypeModelOrderByWithAggregationInput {
  _avg: NativeTypeModelAvgOrderByAggregateInput
  _count: NativeTypeModelCountOrderByAggregateInput
  _max: NativeTypeModelMaxOrderByAggregateInput
  _min: NativeTypeModelMinOrderByAggregateInput
  _sum: NativeTypeModelSumOrderByAggregateInput
  bigInt: SortOrderInput
  byteA: SortOrderInput
  decimal: SortOrderInput
  id: SortOrder
}

input NativeTypeModelOrderByWithRelationAndSearchRelevanceInput {
  bigInt: SortOrderInput
  byteA: SortOrderInput
  decimal: SortOrderInput
  id: SortOrder
}

enum NativeTypeModelScalarFieldEnum {
  bigInt
  byteA
  decimal
  id
}

input NativeTypeModelScalarWhereWithAggregatesInput {
  AND: [NativeTypeModelScalarWhereWithAggregatesInput!]
  NOT: [NativeTypeModelScalarWhereWithAggregatesInput!]
  OR: [NativeTypeModelScalarWhereWithAggregatesInput!]
  bigInt: BigIntNullableWithAggregatesFilter
  byteA: BytesNullableWithAggregatesFilter
  decimal: DecimalNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
}

type NativeTypeModelSumAggregate {
  bigInt: BigInt
  decimal: Decimal
  id: Int
}

input NativeTypeModelSumOrderByAggregateInput {
  bigInt: SortOrder
  decimal: SortOrder
  id: SortOrder
}

input NativeTypeModelUpdateInput {
  bigInt: BigInt
  byteA: Byte
  decimal: Decimal
}

input NativeTypeModelUpdateManyMutationInput {
  bigInt: BigInt
  byteA: Byte
  decimal: Decimal
}

input NativeTypeModelWhereInput {
  AND: [NativeTypeModelWhereInput!]
  NOT: [NativeTypeModelWhereInput!]
  OR: [NativeTypeModelWhereInput!]
  bigInt: BigIntNullableFilter
  byteA: BytesNullableFilter
  decimal: DecimalNullableFilter
  id: IntFilter
}

input NativeTypeModelWhereUniqueInput {
  AND: [NativeTypeModelWhereInput!]
  NOT: [NativeTypeModelWhereInput!]
  OR: [NativeTypeModelWhereInput!]
  bigInt: BigIntNullableFilter
  byteA: BytesNullableFilter
  decimal: DecimalNullableFilter
  id: Int
}

input NestedBigIntNullableFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntNullableFilter
  notIn: [BigInt!]
}

input NestedBigIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedBigIntNullableFilter
  _min: NestedBigIntNullableFilter
  _sum: NestedBigIntNullableFilter
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntNullableWithAggregatesFilter
  notIn: [BigInt!]
}

input NestedBytesNullableFilter {
  equals: Byte
  in: [Byte!]
  not: NestedBytesNullableFilter
  notIn: [Byte!]
}

input NestedBytesNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedBytesNullableFilter
  _min: NestedBytesNullableFilter
  equals: Byte
  in: [Byte!]
  not: NestedBytesNullableWithAggregatesFilter
  notIn: [Byte!]
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDecimalNullableFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableFilter
  notIn: [Decimal!]
}

input NestedDecimalNullableWithAggregatesFilter {
  _avg: NestedDecimalNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedDecimalNullableFilter
  _min: NestedDecimalNullableFilter
  _sum: NestedDecimalNullableFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableWithAggregatesFilter
  notIn: [Decimal!]
}

input NestedEnumPostKindNullableFilter {
  equals: PostKind
  in: [PostKind!]
  not: NestedEnumPostKindNullableFilter
  notIn: [PostKind!]
}

input NestedEnumPostKindNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedEnumPostKindNullableFilter
  _min: NestedEnumPostKindNullableFilter
  equals: PostKind
  in: [PostKind!]
  not: NestedEnumPostKindNullableWithAggregatesFilter
  notIn: [PostKind!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedJsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  search: String
  startsWith: String
}

enum NullsOrder {
  first
  last
}

type Patient {
  email: String!
  firstName: String!
  lastName: String!
}

type PatientCountAggregate {
  _all: Int!
  email: Int!
  firstName: Int!
  lastName: Int!
}

input PatientCountOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
}

input PatientCreateInput {
  email: String!
  firstName: String!
  lastName: String!
}

input PatientCreateManyInput {
  email: String!
  firstName: String!
  lastName: String!
}

input PatientFirstNameLastNameCompoundUniqueInput {
  firstName: String!
  lastName: String!
}

type PatientGroupBy {
  _count: PatientCountAggregate
  _max: PatientMaxAggregate
  _min: PatientMinAggregate
  email: String!
  firstName: String!
  lastName: String!
}

type PatientMaxAggregate {
  email: String
  firstName: String
  lastName: String
}

input PatientMaxOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
}

type PatientMinAggregate {
  email: String
  firstName: String
  lastName: String
}

input PatientMinOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
}

enum PatientOrderByRelevanceFieldEnum {
  email
  firstName
  lastName
}

input PatientOrderByRelevanceInput {
  fields: [PatientOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input PatientOrderByWithAggregationInput {
  _count: PatientCountOrderByAggregateInput
  _max: PatientMaxOrderByAggregateInput
  _min: PatientMinOrderByAggregateInput
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
}

input PatientOrderByWithRelationAndSearchRelevanceInput {
  _relevance: PatientOrderByRelevanceInput
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
}

enum PatientScalarFieldEnum {
  email
  firstName
  lastName
}

input PatientScalarWhereWithAggregatesInput {
  AND: [PatientScalarWhereWithAggregatesInput!]
  NOT: [PatientScalarWhereWithAggregatesInput!]
  OR: [PatientScalarWhereWithAggregatesInput!]
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
}

input PatientUpdateInput {
  email: String
  firstName: String
  lastName: String
}

input PatientUpdateManyMutationInput {
  email: String
  firstName: String
  lastName: String
}

input PatientWhereInput {
  AND: [PatientWhereInput!]
  NOT: [PatientWhereInput!]
  OR: [PatientWhereInput!]
  email: StringFilter
  firstName: StringFilter
  lastName: StringFilter
}

input PatientWhereUniqueInput {
  AND: [PatientWhereInput!]
  NOT: [PatientWhereInput!]
  OR: [PatientWhereInput!]
  email: StringFilter
  firstName: StringFilter
  firstName_lastName: PatientFirstNameLastNameCompoundUniqueInput
  lastName: StringFilter
}

type Post {
  author: MainUser!
  authorId: Int!
  content: String
  createdAt: DateTime!
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  title: String!
  updatedAt: DateTime!

  """
  first line of comment
  second line of comment
  third line of comment
  """
  uuid: ID!
}

type PostAvgAggregate {
  authorId: Float
  editorId: Float
}

input PostAvgOrderByAggregateInput {
  authorId: SortOrder
  editorId: SortOrder
}

type PostCountAggregate {
  _all: Int!
  authorId: Int!
  content: Int!
  createdAt: Int!
  editorId: Int!
  kind: Int!
  metadata: Int!
  published: Int!
  subtitle: Int!
  title: Int!
  updatedAt: Int!
  uuid: Int!
}

input PostCountOrderByAggregateInput {
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  editorId: SortOrder
  kind: SortOrder
  metadata: SortOrder
  subtitle: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  uuid: SortOrder
}

input PostCreateInput {
  author: MainUserCreateNestedOneWithoutPostsInput!
  content: String
  createdAt: DateTime
  editor: MainUserCreateNestedOneWithoutEditorPostsInput
  kind: PostKind
  metadata: JSON!
  subtitle: String!
  title: String!
  uuid: String
}

input PostCreateManyAuthorInput {
  content: String
  createdAt: DateTime
  editorId: Int
  kind: PostKind
  metadata: JSON!
  subtitle: String!
  title: String!
  uuid: String
}

input PostCreateManyAuthorInputEnvelope {
  data: [PostCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input PostCreateManyEditorInput {
  authorId: Int!
  content: String
  createdAt: DateTime
  kind: PostKind
  metadata: JSON!
  subtitle: String!
  title: String!
  uuid: String
}

input PostCreateManyEditorInputEnvelope {
  data: [PostCreateManyEditorInput!]!
  skipDuplicates: Boolean
}

input PostCreateNestedManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
  create: [PostCreateWithoutAuthorInput!]
  createMany: PostCreateManyAuthorInputEnvelope
}

input PostCreateNestedManyWithoutEditorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutEditorInput!]
  create: [PostCreateWithoutEditorInput!]
  createMany: PostCreateManyEditorInputEnvelope
}

input PostCreateOrConnectWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostCreateOrConnectWithoutEditorInput {
  create: PostCreateWithoutEditorInput!
  where: PostWhereUniqueInput!
}

input PostCreateWithoutAuthorInput {
  content: String
  createdAt: DateTime
  editor: MainUserCreateNestedOneWithoutEditorPostsInput
  kind: PostKind
  metadata: JSON!
  subtitle: String!
  title: String!
  uuid: String
}

input PostCreateWithoutEditorInput {
  author: MainUserCreateNestedOneWithoutPostsInput!
  content: String
  createdAt: DateTime
  kind: PostKind
  metadata: JSON!
  subtitle: String!
  title: String!
  uuid: String
}

type PostGroupBy {
  _avg: PostAvgAggregate
  _count: PostCountAggregate
  _max: PostMaxAggregate
  _min: PostMinAggregate
  _sum: PostSumAggregate
  authorId: Int!
  content: String
  createdAt: DateTime!
  editorId: Int
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  subtitle: String!
  title: String!
  updatedAt: DateTime!
  uuid: String!
}

enum PostKind {
  ADVERT
  BLOG
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

type PostMaxAggregate {
  authorId: Int
  content: String
  createdAt: DateTime
  editorId: Int
  kind: PostKind
  published: Boolean
  subtitle: String
  title: String
  updatedAt: DateTime
  uuid: String
}

input PostMaxOrderByAggregateInput {
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  editorId: SortOrder
  kind: SortOrder
  subtitle: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  uuid: SortOrder
}

type PostMinAggregate {
  authorId: Int
  content: String
  createdAt: DateTime
  editorId: Int
  kind: PostKind
  published: Boolean
  subtitle: String
  title: String
  updatedAt: DateTime
  uuid: String
}

input PostMinOrderByAggregateInput {
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  editorId: SortOrder
  kind: SortOrder
  subtitle: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  uuid: SortOrder
}

input PostOrderByRelationAggregateInput {
  _count: SortOrder
}

enum PostOrderByRelevanceFieldEnum {
  content
  subtitle
  title
  uuid
}

input PostOrderByRelevanceInput {
  fields: [PostOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input PostOrderByWithAggregationInput {
  _avg: PostAvgOrderByAggregateInput
  _count: PostCountOrderByAggregateInput
  _max: PostMaxOrderByAggregateInput
  _min: PostMinOrderByAggregateInput
  _sum: PostSumOrderByAggregateInput
  authorId: SortOrder
  content: SortOrderInput
  createdAt: SortOrder
  editorId: SortOrderInput
  kind: SortOrderInput
  metadata: SortOrder
  subtitle: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  uuid: SortOrder
}

input PostOrderByWithRelationAndSearchRelevanceInput {
  _relevance: PostOrderByRelevanceInput
  author: MainUserOrderByWithRelationAndSearchRelevanceInput
  authorId: SortOrder
  content: SortOrderInput
  createdAt: SortOrder
  editor: MainUserOrderByWithRelationAndSearchRelevanceInput
  editorId: SortOrderInput
  kind: SortOrderInput
  metadata: SortOrder
  subtitle: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  uuid: SortOrder
}

enum PostScalarFieldEnum {
  authorId
  content
  createdAt
  editorId
  kind
  metadata
  published
  subtitle
  title
  updatedAt
  uuid
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  authorId: IntFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  editorId: IntNullableFilter
  kind: EnumPostKindNullableFilter
  metadata: JsonFilter
  subtitle: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  uuid: StringFilter
}

input PostScalarWhereWithAggregatesInput {
  AND: [PostScalarWhereWithAggregatesInput!]
  NOT: [PostScalarWhereWithAggregatesInput!]
  OR: [PostScalarWhereWithAggregatesInput!]
  authorId: IntWithAggregatesFilter
  content: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  editorId: IntNullableWithAggregatesFilter
  kind: EnumPostKindNullableWithAggregatesFilter
  metadata: JsonWithAggregatesFilter
  subtitle: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  uuid: StringWithAggregatesFilter
}

type PostSumAggregate {
  authorId: Int
  editorId: Int
}

input PostSumOrderByAggregateInput {
  authorId: SortOrder
  editorId: SortOrder
}

input PostUpdateManyMutationInput {
  content: String
  createdAt: DateTime
  kind: PostKind
  metadata: JSON
  subtitle: String
  title: String
  uuid: String
}

input PostUpdateManyWithWhereWithoutAuthorInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithWhereWithoutEditorInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithoutAuthorNestedInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
  create: [PostCreateWithoutAuthorInput!]
  createMany: PostCreateManyAuthorInputEnvelope
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [PostUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input PostUpdateManyWithoutEditorNestedInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutEditorInput!]
  create: [PostCreateWithoutEditorInput!]
  createMany: PostCreateManyEditorInputEnvelope
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutEditorInput!]
  updateMany: [PostUpdateManyWithWhereWithoutEditorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutEditorInput!]
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  data: PostUpdateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithWhereUniqueWithoutEditorInput {
  data: PostUpdateWithoutEditorInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithoutAuthorInput {
  content: String
  createdAt: DateTime
  editor: MainUserUpdateOneWithoutEditorPostsNestedInput
  kind: PostKind
  metadata: JSON
  subtitle: String
  title: String
  uuid: String
}

input PostUpdateWithoutEditorInput {
  author: MainUserUpdateOneRequiredWithoutPostsNestedInput
  content: String
  createdAt: DateTime
  kind: PostKind
  metadata: JSON
  subtitle: String
  title: String
  uuid: String
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  update: PostUpdateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithWhereUniqueWithoutEditorInput {
  create: PostCreateWithoutEditorInput!
  update: PostUpdateWithoutEditorInput!
  where: PostWhereUniqueInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  author: MainUserRelationFilter
  authorId: IntFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  editor: MainUserRelationFilter
  editorId: IntNullableFilter
  kind: EnumPostKindNullableFilter
  metadata: JsonFilter
  subtitle: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  uuid: StringFilter
}

input PostWhereUniqueInput {
  AND: [PostWhereInput!]
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  author: MainUserRelationFilter
  authorId: IntFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  editor: MainUserRelationFilter
  editorId: IntNullableFilter
  kind: EnumPostKindNullableFilter
  metadata: JsonFilter
  subtitle: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  uuid: String
}

type Problem {
  _count: ProblemCount
  creator(where: CreatorWhereInput): Creator
  creatorId: Int
  id: ID!
  likedBy(cursor: CreatorWhereUniqueInput, distinct: [CreatorScalarFieldEnum!], orderBy: [CreatorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: CreatorWhereInput): [Creator!]!
  problemText: String!
}

type ProblemAvgAggregate {
  creatorId: Float
  id: Float
}

input ProblemAvgOrderByAggregateInput {
  creatorId: SortOrder
  id: SortOrder
}

type ProblemCount {
  likedBy(where: CreatorWhereInput): Int!
}

type ProblemCountAggregate {
  _all: Int!
  creatorId: Int!
  id: Int!
  problemText: Int!
}

input ProblemCountOrderByAggregateInput {
  creatorId: SortOrder
  id: SortOrder
  problemText: SortOrder
}

input ProblemCreateInput {
  creator: CreatorCreateNestedOneWithoutProblemsInput
  likedBy: CreatorCreateNestedManyWithoutLikesInput
  problemText: String!
}

input ProblemCreateManyCreatorInput {
  id: Int
  problemText: String!
}

input ProblemCreateManyCreatorInputEnvelope {
  data: [ProblemCreateManyCreatorInput!]!
  skipDuplicates: Boolean
}

input ProblemCreateManyInput {
  creatorId: Int
  id: Int
  problemText: String!
}

input ProblemCreateNestedManyWithoutCreatorInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutCreatorInput!]
  create: [ProblemCreateWithoutCreatorInput!]
  createMany: ProblemCreateManyCreatorInputEnvelope
}

input ProblemCreateNestedManyWithoutLikedByInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutLikedByInput!]
  create: [ProblemCreateWithoutLikedByInput!]
}

input ProblemCreateOrConnectWithoutCreatorInput {
  create: ProblemCreateWithoutCreatorInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateOrConnectWithoutLikedByInput {
  create: ProblemCreateWithoutLikedByInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateWithoutCreatorInput {
  likedBy: CreatorCreateNestedManyWithoutLikesInput
  problemText: String!
}

input ProblemCreateWithoutLikedByInput {
  creator: CreatorCreateNestedOneWithoutProblemsInput
  problemText: String!
}

type ProblemGroupBy {
  _avg: ProblemAvgAggregate
  _count: ProblemCountAggregate
  _max: ProblemMaxAggregate
  _min: ProblemMinAggregate
  _sum: ProblemSumAggregate
  creatorId: Int
  id: Int!
  problemText: String!
}

input ProblemListRelationFilter {
  every: ProblemWhereInput
  none: ProblemWhereInput
  some: ProblemWhereInput
}

type ProblemMaxAggregate {
  creatorId: Int
  id: Int
  problemText: String
}

input ProblemMaxOrderByAggregateInput {
  creatorId: SortOrder
  id: SortOrder
  problemText: SortOrder
}

type ProblemMinAggregate {
  creatorId: Int
  id: Int
  problemText: String
}

input ProblemMinOrderByAggregateInput {
  creatorId: SortOrder
  id: SortOrder
  problemText: SortOrder
}

input ProblemOrderByRelationAggregateInput {
  _count: SortOrder
}

enum ProblemOrderByRelevanceFieldEnum {
  problemText
}

input ProblemOrderByRelevanceInput {
  fields: [ProblemOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input ProblemOrderByWithAggregationInput {
  _avg: ProblemAvgOrderByAggregateInput
  _count: ProblemCountOrderByAggregateInput
  _max: ProblemMaxOrderByAggregateInput
  _min: ProblemMinOrderByAggregateInput
  _sum: ProblemSumOrderByAggregateInput
  creatorId: SortOrderInput
  id: SortOrder
  problemText: SortOrder
}

input ProblemOrderByWithRelationAndSearchRelevanceInput {
  _relevance: ProblemOrderByRelevanceInput
  creator: CreatorOrderByWithRelationAndSearchRelevanceInput
  creatorId: SortOrderInput
  id: SortOrder
  likedBy: CreatorOrderByRelationAggregateInput
  problemText: SortOrder
}

enum ProblemScalarFieldEnum {
  creatorId
  id
  problemText
}

input ProblemScalarWhereInput {
  AND: [ProblemScalarWhereInput!]
  NOT: [ProblemScalarWhereInput!]
  OR: [ProblemScalarWhereInput!]
  creatorId: IntNullableFilter
  id: IntFilter
  problemText: StringFilter
}

input ProblemScalarWhereWithAggregatesInput {
  AND: [ProblemScalarWhereWithAggregatesInput!]
  NOT: [ProblemScalarWhereWithAggregatesInput!]
  OR: [ProblemScalarWhereWithAggregatesInput!]
  creatorId: IntNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  problemText: StringWithAggregatesFilter
}

type ProblemSumAggregate {
  creatorId: Int
  id: Int
}

input ProblemSumOrderByAggregateInput {
  creatorId: SortOrder
  id: SortOrder
}

input ProblemUpdateInput {
  creator: CreatorUpdateOneWithoutProblemsNestedInput
  likedBy: CreatorUpdateManyWithoutLikesNestedInput
  problemText: String
}

input ProblemUpdateManyMutationInput {
  problemText: String
}

input ProblemUpdateManyWithWhereWithoutCreatorInput {
  data: ProblemUpdateManyMutationInput!
  where: ProblemScalarWhereInput!
}

input ProblemUpdateManyWithWhereWithoutLikedByInput {
  data: ProblemUpdateManyMutationInput!
  where: ProblemScalarWhereInput!
}

input ProblemUpdateManyWithoutCreatorNestedInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutCreatorInput!]
  create: [ProblemCreateWithoutCreatorInput!]
  createMany: ProblemCreateManyCreatorInputEnvelope
  delete: [ProblemWhereUniqueInput!]
  deleteMany: [ProblemScalarWhereInput!]
  disconnect: [ProblemWhereUniqueInput!]
  set: [ProblemWhereUniqueInput!]
  update: [ProblemUpdateWithWhereUniqueWithoutCreatorInput!]
  updateMany: [ProblemUpdateManyWithWhereWithoutCreatorInput!]
  upsert: [ProblemUpsertWithWhereUniqueWithoutCreatorInput!]
}

input ProblemUpdateManyWithoutLikedByNestedInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutLikedByInput!]
  create: [ProblemCreateWithoutLikedByInput!]
  delete: [ProblemWhereUniqueInput!]
  deleteMany: [ProblemScalarWhereInput!]
  disconnect: [ProblemWhereUniqueInput!]
  set: [ProblemWhereUniqueInput!]
  update: [ProblemUpdateWithWhereUniqueWithoutLikedByInput!]
  updateMany: [ProblemUpdateManyWithWhereWithoutLikedByInput!]
  upsert: [ProblemUpsertWithWhereUniqueWithoutLikedByInput!]
}

input ProblemUpdateWithWhereUniqueWithoutCreatorInput {
  data: ProblemUpdateWithoutCreatorInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpdateWithWhereUniqueWithoutLikedByInput {
  data: ProblemUpdateWithoutLikedByInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpdateWithoutCreatorInput {
  likedBy: CreatorUpdateManyWithoutLikesNestedInput
  problemText: String
}

input ProblemUpdateWithoutLikedByInput {
  creator: CreatorUpdateOneWithoutProblemsNestedInput
  problemText: String
}

input ProblemUpsertWithWhereUniqueWithoutCreatorInput {
  create: ProblemCreateWithoutCreatorInput!
  update: ProblemUpdateWithoutCreatorInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpsertWithWhereUniqueWithoutLikedByInput {
  create: ProblemCreateWithoutLikedByInput!
  update: ProblemUpdateWithoutLikedByInput!
  where: ProblemWhereUniqueInput!
}

input ProblemWhereInput {
  AND: [ProblemWhereInput!]
  NOT: [ProblemWhereInput!]
  OR: [ProblemWhereInput!]
  creator: CreatorRelationFilter
  creatorId: IntNullableFilter
  id: IntFilter
  likedBy: CreatorListRelationFilter
  problemText: StringFilter
}

input ProblemWhereUniqueInput {
  AND: [ProblemWhereInput!]
  NOT: [ProblemWhereInput!]
  OR: [ProblemWhereInput!]
  creator: CreatorRelationFilter
  creatorId: IntNullableFilter
  id: Int
  likedBy: CreatorListRelationFilter
  problemText: StringFilter
}

type Query {
  aggregateCreator(cursor: CreatorWhereUniqueInput, orderBy: [CreatorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: CreatorWhereInput): AggregateCreator!
  aggregateDirector(cursor: DirectorWhereUniqueInput, orderBy: [DirectorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: DirectorWhereInput): AggregateDirector!
  aggregateMainUser(cursor: MainUserWhereUniqueInput, orderBy: [MainUserOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MainUserWhereInput): AggregateMainUser!
  aggregateMovie(cursor: MovieWhereUniqueInput, orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): AggregateMovie!
  aggregateNativeTypeModel(cursor: NativeTypeModelWhereUniqueInput, orderBy: [NativeTypeModelOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: NativeTypeModelWhereInput): AggregateNativeTypeModel!
  aggregatePatient(cursor: PatientWhereUniqueInput, orderBy: [PatientOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: PatientWhereInput): AggregatePatient!
  aggregateProblem(cursor: ProblemWhereUniqueInput, orderBy: [ProblemOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ProblemWhereInput): AggregateProblem!
  allMainUsers: [MainUser!]!
  allPosts: [Post!]!
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  creator(where: CreatorWhereUniqueInput!): Creator
  creators(cursor: CreatorWhereUniqueInput, distinct: [CreatorScalarFieldEnum!], orderBy: [CreatorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: CreatorWhereInput): [Creator!]!
  customFindMainUsersWithArgs(cursor: MainUserWhereUniqueInput, distinct: [MainUserScalarFieldEnum!], orderBy: [MainUserOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MainUserWhereInput): [MainUser!]!
  director(where: DirectorWhereUniqueInput!): Director
  directors(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: DirectorWhereInput): [Director!]!
  findFirstCreator(cursor: CreatorWhereUniqueInput, distinct: [CreatorScalarFieldEnum!], orderBy: [CreatorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: CreatorWhereInput): Creator
  findFirstCreatorOrThrow(cursor: CreatorWhereUniqueInput, distinct: [CreatorScalarFieldEnum!], orderBy: [CreatorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: CreatorWhereInput): Creator
  findFirstDirector(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: DirectorWhereInput): Director
  findFirstDirectorOrThrow(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: DirectorWhereInput): Director
  findFirstMainUser(cursor: MainUserWhereUniqueInput, distinct: [MainUserScalarFieldEnum!], orderBy: [MainUserOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MainUserWhereInput): MainUser
  findFirstMainUserOrThrow(cursor: MainUserWhereUniqueInput, distinct: [MainUserScalarFieldEnum!], orderBy: [MainUserOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MainUserWhereInput): MainUser
  findFirstMovie(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): Movie
  findFirstMovieOrThrow(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): Movie
  findFirstNativeTypeModel(cursor: NativeTypeModelWhereUniqueInput, distinct: [NativeTypeModelScalarFieldEnum!], orderBy: [NativeTypeModelOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: NativeTypeModelWhereInput): NativeTypeModel
  findFirstNativeTypeModelOrThrow(cursor: NativeTypeModelWhereUniqueInput, distinct: [NativeTypeModelScalarFieldEnum!], orderBy: [NativeTypeModelOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: NativeTypeModelWhereInput): NativeTypeModel
  findFirstPatient(cursor: PatientWhereUniqueInput, distinct: [PatientScalarFieldEnum!], orderBy: [PatientOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: PatientWhereInput): Patient
  findFirstPatientOrThrow(cursor: PatientWhereUniqueInput, distinct: [PatientScalarFieldEnum!], orderBy: [PatientOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: PatientWhereInput): Patient
  findFirstProblem(cursor: ProblemWhereUniqueInput, distinct: [ProblemScalarFieldEnum!], orderBy: [ProblemOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ProblemWhereInput): Problem
  findFirstProblemOrThrow(cursor: ProblemWhereUniqueInput, distinct: [ProblemScalarFieldEnum!], orderBy: [ProblemOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ProblemWhereInput): Problem
  getCreator(where: CreatorWhereUniqueInput!): Creator
  getDirector(where: DirectorWhereUniqueInput!): Director
  getMainUser(where: MainUserWhereUniqueInput!): MainUser
  getMovie(where: MovieWhereUniqueInput!): Movie
  getNativeTypeModel(where: NativeTypeModelWhereUniqueInput!): NativeTypeModel
  getPatient(where: PatientWhereUniqueInput!): Patient
  getProblem(where: ProblemWhereUniqueInput!): Problem
  groupByCategory(by: [CategoryScalarFieldEnum!]!, having: CategoryScalarWhereWithAggregatesInput, orderBy: [CategoryOrderByWithAggregationInput!], skip: Int, take: Int, where: CategoryWhereInput): [CategoryGroupBy!]!
  groupByCreator(by: [CreatorScalarFieldEnum!]!, having: CreatorScalarWhereWithAggregatesInput, orderBy: [CreatorOrderByWithAggregationInput!], skip: Int, take: Int, where: CreatorWhereInput): [CreatorGroupBy!]!
  groupByDirector(by: [DirectorScalarFieldEnum!]!, having: DirectorScalarWhereWithAggregatesInput, orderBy: [DirectorOrderByWithAggregationInput!], skip: Int, take: Int, where: DirectorWhereInput): [DirectorGroupBy!]!
  groupByMainUser(by: [MainUserScalarFieldEnum!]!, having: MainUserScalarWhereWithAggregatesInput, orderBy: [MainUserOrderByWithAggregationInput!], skip: Int, take: Int, where: MainUserWhereInput): [MainUserGroupBy!]!
  groupByMovie(by: [MovieScalarFieldEnum!]!, having: MovieScalarWhereWithAggregatesInput, orderBy: [MovieOrderByWithAggregationInput!], skip: Int, take: Int, where: MovieWhereInput): [MovieGroupBy!]!
  groupByNativeTypeModel(by: [NativeTypeModelScalarFieldEnum!]!, having: NativeTypeModelScalarWhereWithAggregatesInput, orderBy: [NativeTypeModelOrderByWithAggregationInput!], skip: Int, take: Int, where: NativeTypeModelWhereInput): [NativeTypeModelGroupBy!]!
  groupByPatient(by: [PatientScalarFieldEnum!]!, having: PatientScalarWhereWithAggregatesInput, orderBy: [PatientOrderByWithAggregationInput!], skip: Int, take: Int, where: PatientWhereInput): [PatientGroupBy!]!
  groupByPost(by: [PostScalarFieldEnum!]!, having: PostScalarWhereWithAggregatesInput, orderBy: [PostOrderByWithAggregationInput!], skip: Int, take: Int, where: PostWhereInput): [PostGroupBy!]!
  groupByProblem(by: [ProblemScalarFieldEnum!]!, having: ProblemScalarWhereWithAggregatesInput, orderBy: [ProblemOrderByWithAggregationInput!], skip: Int, take: Int, where: ProblemWhereInput): [ProblemGroupBy!]!
  mainUser(where: MainUserWhereUniqueInput!): MainUser
  mainUsers(cursor: MainUserWhereUniqueInput, distinct: [MainUserScalarFieldEnum!], orderBy: [MainUserOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MainUserWhereInput): [MainUser!]!
  movie(where: MovieWhereUniqueInput!): Movie
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
  nativeTypeModel(where: NativeTypeModelWhereUniqueInput!): NativeTypeModel
  nativeTypeModels(cursor: NativeTypeModelWhereUniqueInput, distinct: [NativeTypeModelScalarFieldEnum!], orderBy: [NativeTypeModelOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: NativeTypeModelWhereInput): [NativeTypeModel!]!
  patient(where: PatientWhereUniqueInput!): Patient
  patients(cursor: PatientWhereUniqueInput, distinct: [PatientScalarFieldEnum!], orderBy: [PatientOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: PatientWhereInput): [Patient!]!
  post(where: PostWhereUniqueInput!): Post
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  problem(where: ProblemWhereUniqueInput!): Problem
  problems(cursor: ProblemWhereUniqueInput, distinct: [ProblemScalarFieldEnum!], orderBy: [ProblemOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: ProblemWhereInput): [Problem!]!
}

enum QueryMode {
  default
  insensitive
}

"""Role enum doc"""
enum Role {
  ADMIN
  USER
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  search: String
  startsWith: String
}