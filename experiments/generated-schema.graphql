# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateClient {
  _avg: ClientAvgAggregate
  _count: ClientCountAggregate
  _max: ClientMaxAggregate
  _min: ClientMinAggregate
  _sum: ClientSumAggregate
}

type AggregateCreator {
  _avg: CreatorAvgAggregate
  _count: CreatorCountAggregate
  _max: CreatorMaxAggregate
  _min: CreatorMinAggregate
  _sum: CreatorSumAggregate
}

type AggregateDirector {
  _count: DirectorCountAggregate
  _max: DirectorMaxAggregate
  _min: DirectorMinAggregate
}

type AggregateMovie {
  _count: MovieCountAggregate
  _max: MovieMaxAggregate
  _min: MovieMinAggregate
}

type AggregateNativeTypeModel {
  _avg: NativeTypeModelAvgAggregate
  _count: NativeTypeModelCountAggregate
  _max: NativeTypeModelMaxAggregate
  _min: NativeTypeModelMinAggregate
  _sum: NativeTypeModelSumAggregate
}

type AggregatePatient {
  _count: PatientCountAggregate
  _max: PatientMaxAggregate
  _min: PatientMinAggregate
}

type AggregateProblem {
  _avg: ProblemAvgAggregate
  _count: ProblemCountAggregate
  _max: ProblemMaxAggregate
  _min: ProblemMinAggregate
  _sum: ProblemSumAggregate
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

input BigIntNullableFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntNullableFilter
  notIn: [BigInt!]
}

input BigIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedBigIntNullableFilter
  _min: NestedBigIntNullableFilter
  _sum: NestedBigIntNullableFilter
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntNullableWithAggregatesFilter
  notIn: [BigInt!]
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

"""The `Byte` scalar type represents byte value as a Buffer"""
scalar Byte

input BytesNullableFilter {
  equals: Byte
  not: NestedBytesNullableFilter
}

input BytesNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedBytesNullableFilter
  _min: NestedBytesNullableFilter
  equals: Byte
  not: NestedBytesNullableWithAggregatesFilter
}

type Category {
  name: String!
  number: Int!
  slug: String!
}

type CategoryAvgAggregate {
  number: Float
}

input CategoryAvgOrderByAggregateInput {
  number: SortOrder
}

type CategoryCountAggregate {
  _all: Int!
  name: Int!
  number: Int!
  slug: Int!
}

input CategoryCountOrderByAggregateInput {
  name: SortOrder
  number: SortOrder
  slug: SortOrder
}

type CategoryGroupBy {
  _avg: CategoryAvgAggregate
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
  _sum: CategorySumAggregate
  name: String!
  number: Int!
  slug: String!
}

type CategoryMaxAggregate {
  name: String
  number: Int
  slug: String
}

input CategoryMaxOrderByAggregateInput {
  name: SortOrder
  number: SortOrder
  slug: SortOrder
}

type CategoryMinAggregate {
  name: String
  number: Int
  slug: String
}

input CategoryMinOrderByAggregateInput {
  name: SortOrder
  number: SortOrder
  slug: SortOrder
}

input CategoryOrderByWithAggregationInput {
  _avg: CategoryAvgOrderByAggregateInput
  _count: CategoryCountOrderByAggregateInput
  _max: CategoryMaxOrderByAggregateInput
  _min: CategoryMinOrderByAggregateInput
  _sum: CategorySumOrderByAggregateInput
  name: SortOrder
  number: SortOrder
  slug: SortOrder
}

input CategoryOrderByWithRelationInput {
  name: SortOrder
  number: SortOrder
  slug: SortOrder
}

enum CategoryScalarFieldEnum {
  name
  number
  slug
}

input CategoryScalarWhereWithAggregatesInput {
  AND: [CategoryScalarWhereWithAggregatesInput!]
  NOT: [CategoryScalarWhereWithAggregatesInput!]
  OR: [CategoryScalarWhereWithAggregatesInput!]
  name: StringWithAggregatesFilter
  number: IntWithAggregatesFilter
  slug: StringWithAggregatesFilter
}

input CategorySlugNumberCompoundUniqueInput {
  number: Int!
  slug: String!
}

type CategorySumAggregate {
  number: Int
}

input CategorySumOrderByAggregateInput {
  number: SortOrder
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  name: StringFilter
  number: IntFilter
  slug: StringFilter
}

input CategoryWhereUniqueInput {
  slug_number: CategorySlugNumberCompoundUniqueInput
}

"""User model doc"""
type Client {
  _count: ClientCount
  accountBalance: Float!
  age: Int!
  aliases: [String!]!
  amount: Float!
  clientPosts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  email: String!

  """renamed field doc"""
  firstName: String
  grades: [Int!]!
  hello: String!

  """User model field doc"""
  id: Int!
  role: Role!
}

type ClientAvgAggregate {
  age: Float
  amount: Float
  balance: Float
  grades: Float
  id: Float
}

input ClientAvgOrderByAggregateInput {
  accountBalance: SortOrder
  age: SortOrder
  amount: SortOrder
  grades: SortOrder
  id: SortOrder
}

type ClientCount {
  editorPosts: Int!
  posts: Int!
}

type ClientCountAggregate {
  _all: Int!
  age: Int!
  aliases: Int!
  amount: Int!
  balance: Int!
  email: Int!
  grades: Int!
  id: Int!
  name: Int!
  role: Int!
}

input ClientCountOrderByAggregateInput {
  accountBalance: SortOrder
  age: SortOrder
  aliases: SortOrder
  amount: SortOrder
  email: SortOrder
  firstName: SortOrder
  grades: SortOrder
  id: SortOrder
  role: SortOrder
}

input ClientCreateInput {
  accountBalance: Float!
  age: Int!
  aliases: ClientCreatealiasesInput
  amount: Float!
  clientPosts: PostCreateNestedManyWithoutAuthorInput
  editorPosts: PostCreateNestedManyWithoutEditorInput
  email: String!
  firstName: String
  grades: ClientCreategradesInput
  role: Role!
}

input ClientCreateManyInput {
  accountBalance: Float!
  age: Int!
  aliases: ClientCreateManyaliasesInput
  amount: Float!
  email: String!
  firstName: String
  grades: ClientCreateManygradesInput
  id: Int
  role: Role!
}

input ClientCreateManyaliasesInput {
  set: [String!]!
}

input ClientCreateManygradesInput {
  set: [Int!]!
}

input ClientCreateNestedOneWithoutEditorPostsInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutEditorPostsInput
  create: ClientCreateWithoutEditorPostsInput
}

input ClientCreateNestedOneWithoutPostsInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutPostsInput
  create: ClientCreateWithoutPostsInput
}

input ClientCreateOrConnectWithoutEditorPostsInput {
  create: ClientCreateWithoutEditorPostsInput!
  where: ClientWhereUniqueInput!
}

input ClientCreateOrConnectWithoutPostsInput {
  create: ClientCreateWithoutPostsInput!
  where: ClientWhereUniqueInput!
}

input ClientCreateWithoutEditorPostsInput {
  accountBalance: Float!
  age: Int!
  aliases: ClientCreatealiasesInput
  amount: Float!
  clientPosts: PostCreateNestedManyWithoutAuthorInput
  email: String!
  firstName: String
  grades: ClientCreategradesInput
  role: Role!
}

input ClientCreateWithoutPostsInput {
  accountBalance: Float!
  age: Int!
  aliases: ClientCreatealiasesInput
  amount: Float!
  editorPosts: PostCreateNestedManyWithoutEditorInput
  email: String!
  firstName: String
  grades: ClientCreategradesInput
  role: Role!
}

input ClientCreatealiasesInput {
  set: [String!]!
}

input ClientCreategradesInput {
  set: [Int!]!
}

type ClientGroupBy {
  _avg: ClientAvgAggregate
  _count: ClientCountAggregate
  _max: ClientMaxAggregate
  _min: ClientMinAggregate
  _sum: ClientSumAggregate
  age: Int!
  aliases: [String!]
  amount: Float!
  balance: Float!
  email: String!
  grades: [Int!]
  id: Int!
  name: String
  role: Role!
}

type ClientMaxAggregate {
  age: Int
  amount: Float
  balance: Float
  email: String
  id: Int
  name: String
  role: Role
}

input ClientMaxOrderByAggregateInput {
  accountBalance: SortOrder
  age: SortOrder
  amount: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  role: SortOrder
}

type ClientMinAggregate {
  age: Int
  amount: Float
  balance: Float
  email: String
  id: Int
  name: String
  role: Role
}

input ClientMinOrderByAggregateInput {
  accountBalance: SortOrder
  age: SortOrder
  amount: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  role: SortOrder
}

input ClientOrderByWithAggregationInput {
  _avg: ClientAvgOrderByAggregateInput
  _count: ClientCountOrderByAggregateInput
  _max: ClientMaxOrderByAggregateInput
  _min: ClientMinOrderByAggregateInput
  _sum: ClientSumOrderByAggregateInput
  accountBalance: SortOrder
  age: SortOrder
  aliases: SortOrder
  amount: SortOrder
  email: SortOrder
  firstName: SortOrder
  grades: SortOrder
  id: SortOrder
  role: SortOrder
}

input ClientOrderByWithRelationInput {
  accountBalance: SortOrder
  age: SortOrder
  aliases: SortOrder
  amount: SortOrder
  clientPosts: PostOrderByRelationAggregateInput
  editorPosts: PostOrderByRelationAggregateInput
  email: SortOrder
  firstName: SortOrder
  grades: SortOrder
  id: SortOrder
  role: SortOrder
}

input ClientRelationFilter {
  is: ClientWhereInput
  isNot: ClientWhereInput
}

enum ClientScalarFieldEnum {
  accountBalance
  age
  aliases
  amount
  email
  firstName
  grades
  id
  role
}

input ClientScalarWhereWithAggregatesInput {
  AND: [ClientScalarWhereWithAggregatesInput!]
  NOT: [ClientScalarWhereWithAggregatesInput!]
  OR: [ClientScalarWhereWithAggregatesInput!]
  accountBalance: FloatWithAggregatesFilter
  age: IntWithAggregatesFilter
  aliases: StringNullableListFilter
  amount: FloatWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringNullableWithAggregatesFilter
  grades: IntNullableListFilter
  id: IntWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
}

type ClientSumAggregate {
  age: Int
  amount: Float
  balance: Float
  grades: [Int!]
  id: Int
}

input ClientSumOrderByAggregateInput {
  accountBalance: SortOrder
  age: SortOrder
  amount: SortOrder
  grades: SortOrder
  id: SortOrder
}

input ClientUpdateInput {
  accountBalance: FloatFieldUpdateOperationsInput
  age: IntFieldUpdateOperationsInput
  aliases: ClientUpdatealiasesInput
  amount: FloatFieldUpdateOperationsInput
  clientPosts: PostUpdateManyWithoutAuthorInput
  editorPosts: PostUpdateManyWithoutEditorInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  grades: ClientUpdategradesInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ClientUpdateManyMutationInput {
  accountBalance: FloatFieldUpdateOperationsInput
  age: IntFieldUpdateOperationsInput
  aliases: ClientUpdatealiasesInput
  amount: FloatFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  grades: ClientUpdategradesInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ClientUpdateOneRequiredWithoutPostsInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutPostsInput
  create: ClientCreateWithoutPostsInput
  update: ClientUpdateWithoutPostsInput
  upsert: ClientUpsertWithoutPostsInput
}

input ClientUpdateOneWithoutEditorPostsInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutEditorPostsInput
  create: ClientCreateWithoutEditorPostsInput
  delete: Boolean
  disconnect: Boolean
  update: ClientUpdateWithoutEditorPostsInput
  upsert: ClientUpsertWithoutEditorPostsInput
}

input ClientUpdateWithoutEditorPostsInput {
  accountBalance: FloatFieldUpdateOperationsInput
  age: IntFieldUpdateOperationsInput
  aliases: ClientUpdatealiasesInput
  amount: FloatFieldUpdateOperationsInput
  clientPosts: PostUpdateManyWithoutAuthorInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  grades: ClientUpdategradesInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ClientUpdateWithoutPostsInput {
  accountBalance: FloatFieldUpdateOperationsInput
  age: IntFieldUpdateOperationsInput
  aliases: ClientUpdatealiasesInput
  amount: FloatFieldUpdateOperationsInput
  editorPosts: PostUpdateManyWithoutEditorInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  grades: ClientUpdategradesInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ClientUpdatealiasesInput {
  push: [String!]
  set: [String!]
}

input ClientUpdategradesInput {
  push: [Int!]
  set: [Int!]
}

input ClientUpsertWithoutEditorPostsInput {
  create: ClientCreateWithoutEditorPostsInput!
  update: ClientUpdateWithoutEditorPostsInput!
}

input ClientUpsertWithoutPostsInput {
  create: ClientCreateWithoutPostsInput!
  update: ClientUpdateWithoutPostsInput!
}

input ClientWhereInput {
  AND: [ClientWhereInput!]
  NOT: [ClientWhereInput!]
  OR: [ClientWhereInput!]
  accountBalance: FloatFilter
  age: IntFilter
  aliases: StringNullableListFilter
  amount: FloatFilter
  clientPosts: PostListRelationFilter
  editorPosts: PostListRelationFilter
  email: StringFilter
  firstName: StringNullableFilter
  grades: IntNullableListFilter
  id: IntFilter
  role: EnumRoleFilter
}

input ClientWhereUniqueInput {
  email: String
  id: Int
}

type Creator {
  _count: CreatorCount
  id: Int!
  likes(cursor: ProblemWhereUniqueInput, distinct: [ProblemScalarFieldEnum!], orderBy: [ProblemOrderByWithRelationInput!], skip: Int, take: Int, where: ProblemWhereInput): [Problem!]!
  name: String!
  problems(cursor: ProblemWhereUniqueInput, distinct: [ProblemScalarFieldEnum!], orderBy: [ProblemOrderByWithRelationInput!], skip: Int, take: Int, where: ProblemWhereInput): [Problem!]!
}

type CreatorAvgAggregate {
  id: Float
}

input CreatorAvgOrderByAggregateInput {
  id: SortOrder
}

type CreatorCount {
  likes: Int!
  problems: Int!
}

type CreatorCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input CreatorCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input CreatorCreateInput {
  likes: ProblemCreateNestedManyWithoutLikedByInput
  name: String!
  problems: ProblemCreateNestedManyWithoutCreatorInput
}

input CreatorCreateManyInput {
  id: Int
  name: String!
}

input CreatorCreateNestedManyWithoutLikesInput {
  connect: [CreatorWhereUniqueInput!]
  connectOrCreate: [CreatorCreateOrConnectWithoutLikesInput!]
  create: [CreatorCreateWithoutLikesInput!]
}

input CreatorCreateNestedOneWithoutProblemsInput {
  connect: CreatorWhereUniqueInput
  connectOrCreate: CreatorCreateOrConnectWithoutProblemsInput
  create: CreatorCreateWithoutProblemsInput
}

input CreatorCreateOrConnectWithoutLikesInput {
  create: CreatorCreateWithoutLikesInput!
  where: CreatorWhereUniqueInput!
}

input CreatorCreateOrConnectWithoutProblemsInput {
  create: CreatorCreateWithoutProblemsInput!
  where: CreatorWhereUniqueInput!
}

input CreatorCreateWithoutLikesInput {
  name: String!
  problems: ProblemCreateNestedManyWithoutCreatorInput
}

input CreatorCreateWithoutProblemsInput {
  likes: ProblemCreateNestedManyWithoutLikedByInput
  name: String!
}

type CreatorGroupBy {
  _avg: CreatorAvgAggregate
  _count: CreatorCountAggregate
  _max: CreatorMaxAggregate
  _min: CreatorMinAggregate
  _sum: CreatorSumAggregate
  id: Int!
  name: String!
}

input CreatorListRelationFilter {
  every: CreatorWhereInput
  none: CreatorWhereInput
  some: CreatorWhereInput
}

type CreatorMaxAggregate {
  id: Int
  name: String
}

input CreatorMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type CreatorMinAggregate {
  id: Int
  name: String
}

input CreatorMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input CreatorOrderByRelationAggregateInput {
  _count: SortOrder
}

input CreatorOrderByWithAggregationInput {
  _avg: CreatorAvgOrderByAggregateInput
  _count: CreatorCountOrderByAggregateInput
  _max: CreatorMaxOrderByAggregateInput
  _min: CreatorMinOrderByAggregateInput
  _sum: CreatorSumOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input CreatorOrderByWithRelationInput {
  id: SortOrder
  likes: ProblemOrderByRelationAggregateInput
  name: SortOrder
  problems: ProblemOrderByRelationAggregateInput
}

input CreatorRelationFilter {
  is: CreatorWhereInput
  isNot: CreatorWhereInput
}

enum CreatorScalarFieldEnum {
  id
  name
}

input CreatorScalarWhereInput {
  AND: [CreatorScalarWhereInput!]
  NOT: [CreatorScalarWhereInput!]
  OR: [CreatorScalarWhereInput!]
  id: IntFilter
  name: StringFilter
}

input CreatorScalarWhereWithAggregatesInput {
  AND: [CreatorScalarWhereWithAggregatesInput!]
  NOT: [CreatorScalarWhereWithAggregatesInput!]
  OR: [CreatorScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type CreatorSumAggregate {
  id: Int
}

input CreatorSumOrderByAggregateInput {
  id: SortOrder
}

input CreatorUpdateInput {
  likes: ProblemUpdateManyWithoutLikedByInput
  name: StringFieldUpdateOperationsInput
  problems: ProblemUpdateManyWithoutCreatorInput
}

input CreatorUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input CreatorUpdateManyWithWhereWithoutLikesInput {
  data: CreatorUpdateManyMutationInput!
  where: CreatorScalarWhereInput!
}

input CreatorUpdateManyWithoutLikesInput {
  connect: [CreatorWhereUniqueInput!]
  connectOrCreate: [CreatorCreateOrConnectWithoutLikesInput!]
  create: [CreatorCreateWithoutLikesInput!]
  delete: [CreatorWhereUniqueInput!]
  deleteMany: [CreatorScalarWhereInput!]
  disconnect: [CreatorWhereUniqueInput!]
  set: [CreatorWhereUniqueInput!]
  update: [CreatorUpdateWithWhereUniqueWithoutLikesInput!]
  updateMany: [CreatorUpdateManyWithWhereWithoutLikesInput!]
  upsert: [CreatorUpsertWithWhereUniqueWithoutLikesInput!]
}

input CreatorUpdateOneWithoutProblemsInput {
  connect: CreatorWhereUniqueInput
  connectOrCreate: CreatorCreateOrConnectWithoutProblemsInput
  create: CreatorCreateWithoutProblemsInput
  delete: Boolean
  disconnect: Boolean
  update: CreatorUpdateWithoutProblemsInput
  upsert: CreatorUpsertWithoutProblemsInput
}

input CreatorUpdateWithWhereUniqueWithoutLikesInput {
  data: CreatorUpdateWithoutLikesInput!
  where: CreatorWhereUniqueInput!
}

input CreatorUpdateWithoutLikesInput {
  name: StringFieldUpdateOperationsInput
  problems: ProblemUpdateManyWithoutCreatorInput
}

input CreatorUpdateWithoutProblemsInput {
  likes: ProblemUpdateManyWithoutLikedByInput
  name: StringFieldUpdateOperationsInput
}

input CreatorUpsertWithWhereUniqueWithoutLikesInput {
  create: CreatorCreateWithoutLikesInput!
  update: CreatorUpdateWithoutLikesInput!
  where: CreatorWhereUniqueInput!
}

input CreatorUpsertWithoutProblemsInput {
  create: CreatorCreateWithoutProblemsInput!
  update: CreatorUpdateWithoutProblemsInput!
}

input CreatorWhereInput {
  AND: [CreatorWhereInput!]
  NOT: [CreatorWhereInput!]
  OR: [CreatorWhereInput!]
  id: IntFilter
  likes: ProblemListRelationFilter
  name: StringFilter
  problems: ProblemListRelationFilter
}

input CreatorWhereUniqueInput {
  id: Int
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

"""
GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library.
"""
scalar Decimal

input DecimalNullableFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableFilter
  notIn: [Decimal!]
}

input DecimalNullableWithAggregatesFilter {
  _avg: NestedDecimalNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedDecimalNullableFilter
  _min: NestedDecimalNullableFilter
  _sum: NestedDecimalNullableFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableWithAggregatesFilter
  notIn: [Decimal!]
}

type Director {
  _count: DirectorCount
  firstName: String!
  lastName: String!
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
}

type DirectorCount {
  movies: Int!
}

type DirectorCountAggregate {
  _all: Int!
  firstName: Int!
  lastName: Int!
}

input DirectorCountOrderByAggregateInput {
  firstName: SortOrder
  lastName: SortOrder
}

input DirectorCreateInput {
  firstName: String!
  lastName: String!
  movies: MovieCreateNestedManyWithoutDirectorInput
}

input DirectorCreateManyInput {
  firstName: String!
  lastName: String!
}

input DirectorCreateNestedOneWithoutMoviesInput {
  connect: DirectorWhereUniqueInput
  connectOrCreate: DirectorCreateOrConnectWithoutMoviesInput
  create: DirectorCreateWithoutMoviesInput
}

input DirectorCreateOrConnectWithoutMoviesInput {
  create: DirectorCreateWithoutMoviesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorCreateWithoutMoviesInput {
  firstName: String!
  lastName: String!
}

input DirectorFirstNameLastNameCompoundUniqueInput {
  firstName: String!
  lastName: String!
}

type DirectorGroupBy {
  _count: DirectorCountAggregate
  _max: DirectorMaxAggregate
  _min: DirectorMinAggregate
  firstName: String!
  lastName: String!
}

type DirectorMaxAggregate {
  firstName: String
  lastName: String
}

input DirectorMaxOrderByAggregateInput {
  firstName: SortOrder
  lastName: SortOrder
}

type DirectorMinAggregate {
  firstName: String
  lastName: String
}

input DirectorMinOrderByAggregateInput {
  firstName: SortOrder
  lastName: SortOrder
}

input DirectorOrderByWithAggregationInput {
  _count: DirectorCountOrderByAggregateInput
  _max: DirectorMaxOrderByAggregateInput
  _min: DirectorMinOrderByAggregateInput
  firstName: SortOrder
  lastName: SortOrder
}

input DirectorOrderByWithRelationInput {
  firstName: SortOrder
  lastName: SortOrder
  movies: MovieOrderByRelationAggregateInput
}

input DirectorRelationFilter {
  is: DirectorWhereInput
  isNot: DirectorWhereInput
}

enum DirectorScalarFieldEnum {
  firstName
  lastName
}

input DirectorScalarWhereWithAggregatesInput {
  AND: [DirectorScalarWhereWithAggregatesInput!]
  NOT: [DirectorScalarWhereWithAggregatesInput!]
  OR: [DirectorScalarWhereWithAggregatesInput!]
  firstName: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
}

input DirectorUpdateInput {
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutDirectorInput
}

input DirectorUpdateManyMutationInput {
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input DirectorUpdateOneRequiredWithoutMoviesInput {
  connect: DirectorWhereUniqueInput
  connectOrCreate: DirectorCreateOrConnectWithoutMoviesInput
  create: DirectorCreateWithoutMoviesInput
  update: DirectorUpdateWithoutMoviesInput
  upsert: DirectorUpsertWithoutMoviesInput
}

input DirectorUpdateWithoutMoviesInput {
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input DirectorUpsertWithoutMoviesInput {
  create: DirectorCreateWithoutMoviesInput!
  update: DirectorUpdateWithoutMoviesInput!
}

input DirectorWhereInput {
  AND: [DirectorWhereInput!]
  NOT: [DirectorWhereInput!]
  OR: [DirectorWhereInput!]
  firstName: StringFilter
  lastName: StringFilter
  movies: MovieListRelationFilter
}

input DirectorWhereUniqueInput {
  firstName_lastName: DirectorFirstNameLastNameCompoundUniqueInput
}

input EnumPostKindNullableFilter {
  equals: PostKind
  in: [PostKind!]
  not: NestedEnumPostKindNullableFilter
  notIn: [PostKind!]
}

input EnumPostKindNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedEnumPostKindNullableFilter
  _min: NestedEnumPostKindNullableFilter
  equals: PostKind
  in: [PostKind!]
  not: NestedEnumPostKindNullableWithAggregatesFilter
  notIn: [PostKind!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableListFilter {
  equals: [Int!]
  has: Int
  hasEvery: [Int!]
  hasSome: [Int!]
  isEmpty: Boolean
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedJsonFilter
  _min: NestedJsonFilter
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

type Movie {
  director: Director!
  directorFirstName: String!
  directorLastName: String!
  title: String!
}

type MovieCountAggregate {
  _all: Int!
  directorFirstName: Int!
  directorLastName: Int!
  title: Int!
}

input MovieCountOrderByAggregateInput {
  directorFirstName: SortOrder
  directorLastName: SortOrder
  title: SortOrder
}

input MovieCreateInput {
  director: DirectorCreateNestedOneWithoutMoviesInput!
  title: String!
}

input MovieCreateManyDirectorInput {
  title: String!
}

input MovieCreateManyDirectorInputEnvelope {
  data: [MovieCreateManyDirectorInput!]!
  skipDuplicates: Boolean
}

input MovieCreateManyInput {
  directorFirstName: String!
  directorLastName: String!
  title: String!
}

input MovieCreateNestedManyWithoutDirectorInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutDirectorInput!]
  create: [MovieCreateWithoutDirectorInput!]
  createMany: MovieCreateManyDirectorInputEnvelope
}

input MovieCreateOrConnectWithoutDirectorInput {
  create: MovieCreateWithoutDirectorInput!
  where: MovieWhereUniqueInput!
}

input MovieCreateWithoutDirectorInput {
  title: String!
}

type MovieGroupBy {
  _count: MovieCountAggregate
  _max: MovieMaxAggregate
  _min: MovieMinAggregate
  directorFirstName: String!
  directorLastName: String!
  title: String!
}

input MovieListRelationFilter {
  every: MovieWhereInput
  none: MovieWhereInput
  some: MovieWhereInput
}

type MovieMaxAggregate {
  directorFirstName: String
  directorLastName: String
  title: String
}

input MovieMaxOrderByAggregateInput {
  directorFirstName: SortOrder
  directorLastName: SortOrder
  title: SortOrder
}

type MovieMinAggregate {
  directorFirstName: String
  directorLastName: String
  title: String
}

input MovieMinOrderByAggregateInput {
  directorFirstName: SortOrder
  directorLastName: SortOrder
  title: SortOrder
}

input MovieMovieCompoundIdCompoundUniqueInput {
  directorFirstName: String!
  directorLastName: String!
  title: String!
}

input MovieOrderByRelationAggregateInput {
  _count: SortOrder
}

input MovieOrderByWithAggregationInput {
  _count: MovieCountOrderByAggregateInput
  _max: MovieMaxOrderByAggregateInput
  _min: MovieMinOrderByAggregateInput
  directorFirstName: SortOrder
  directorLastName: SortOrder
  title: SortOrder
}

input MovieOrderByWithRelationInput {
  director: DirectorOrderByWithRelationInput
  directorFirstName: SortOrder
  directorLastName: SortOrder
  title: SortOrder
}

enum MovieScalarFieldEnum {
  directorFirstName
  directorLastName
  title
}

input MovieScalarWhereInput {
  AND: [MovieScalarWhereInput!]
  NOT: [MovieScalarWhereInput!]
  OR: [MovieScalarWhereInput!]
  directorFirstName: StringFilter
  directorLastName: StringFilter
  title: StringFilter
}

input MovieScalarWhereWithAggregatesInput {
  AND: [MovieScalarWhereWithAggregatesInput!]
  NOT: [MovieScalarWhereWithAggregatesInput!]
  OR: [MovieScalarWhereWithAggregatesInput!]
  directorFirstName: StringWithAggregatesFilter
  directorLastName: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
}

input MovieUpdateInput {
  director: DirectorUpdateOneRequiredWithoutMoviesInput
  title: StringFieldUpdateOperationsInput
}

input MovieUpdateManyMutationInput {
  title: StringFieldUpdateOperationsInput
}

input MovieUpdateManyWithWhereWithoutDirectorInput {
  data: MovieUpdateManyMutationInput!
  where: MovieScalarWhereInput!
}

input MovieUpdateManyWithoutDirectorInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutDirectorInput!]
  create: [MovieCreateWithoutDirectorInput!]
  createMany: MovieCreateManyDirectorInputEnvelope
  delete: [MovieWhereUniqueInput!]
  deleteMany: [MovieScalarWhereInput!]
  disconnect: [MovieWhereUniqueInput!]
  set: [MovieWhereUniqueInput!]
  update: [MovieUpdateWithWhereUniqueWithoutDirectorInput!]
  updateMany: [MovieUpdateManyWithWhereWithoutDirectorInput!]
  upsert: [MovieUpsertWithWhereUniqueWithoutDirectorInput!]
}

input MovieUpdateWithWhereUniqueWithoutDirectorInput {
  data: MovieUpdateWithoutDirectorInput!
  where: MovieWhereUniqueInput!
}

input MovieUpdateWithoutDirectorInput {
  title: StringFieldUpdateOperationsInput
}

input MovieUpsertWithWhereUniqueWithoutDirectorInput {
  create: MovieCreateWithoutDirectorInput!
  update: MovieUpdateWithoutDirectorInput!
  where: MovieWhereUniqueInput!
}

input MovieWhereInput {
  AND: [MovieWhereInput!]
  NOT: [MovieWhereInput!]
  OR: [MovieWhereInput!]
  director: DirectorRelationFilter
  directorFirstName: StringFilter
  directorLastName: StringFilter
  title: StringFilter
}

input MovieWhereUniqueInput {
  movieCompoundId: MovieMovieCompoundIdCompoundUniqueInput
}

type Mutation {
  createClient(data: ClientCreateInput!): Client!
  createCreator(data: CreatorCreateInput!): Creator!
  createDirector(data: DirectorCreateInput!): Director!
  createManyClient(data: [ClientCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCreator(data: [CreatorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyDirector(data: [DirectorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMovie(data: [MovieCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyNativeTypeModel(data: [NativeTypeModelCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPatient(data: [PatientCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyProblem(data: [ProblemCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createMovie(data: MovieCreateInput!): Movie!
  createNativeTypeModel(data: NativeTypeModelCreateInput!): NativeTypeModel!
  createPatient(data: PatientCreateInput!): Patient!
  createPost(data: PostCreateInput!): Post!
  createProblem(data: ProblemCreateInput!): Problem!
  customCreatePost(data: PostCreateInput!): Post!
  deleteClient(where: ClientWhereUniqueInput!): Client
  deleteCreator(where: CreatorWhereUniqueInput!): Creator
  deleteDirector(where: DirectorWhereUniqueInput!): Director
  deleteManyClient(where: ClientWhereInput): AffectedRowsOutput!
  deleteManyCreator(where: CreatorWhereInput): AffectedRowsOutput!
  deleteManyDirector(where: DirectorWhereInput): AffectedRowsOutput!
  deleteManyMovie(where: MovieWhereInput): AffectedRowsOutput!
  deleteManyNativeTypeModel(where: NativeTypeModelWhereInput): AffectedRowsOutput!
  deleteManyPatient(where: PatientWhereInput): AffectedRowsOutput!
  deleteManyProblem(where: ProblemWhereInput): AffectedRowsOutput!
  deleteMovie(where: MovieWhereUniqueInput!): Movie
  deleteNativeTypeModel(where: NativeTypeModelWhereUniqueInput!): NativeTypeModel
  deletePatient(where: PatientWhereUniqueInput!): Patient
  deleteProblem(where: ProblemWhereUniqueInput!): Problem
  updateClient(data: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client
  updateCreator(data: CreatorUpdateInput!, where: CreatorWhereUniqueInput!): Creator
  updateDirector(data: DirectorUpdateInput!, where: DirectorWhereUniqueInput!): Director
  updateManyClient(data: ClientUpdateManyMutationInput!, where: ClientWhereInput): AffectedRowsOutput!
  updateManyCreator(data: CreatorUpdateManyMutationInput!, where: CreatorWhereInput): AffectedRowsOutput!
  updateManyDirector(data: DirectorUpdateManyMutationInput!, where: DirectorWhereInput): AffectedRowsOutput!
  updateManyMovie(data: MovieUpdateManyMutationInput!, where: MovieWhereInput): AffectedRowsOutput!
  updateManyNativeTypeModel(data: NativeTypeModelUpdateManyMutationInput!, where: NativeTypeModelWhereInput): AffectedRowsOutput!
  updateManyPatient(data: PatientUpdateManyMutationInput!, where: PatientWhereInput): AffectedRowsOutput!
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): AffectedRowsOutput!
  updateManyProblem(data: ProblemUpdateManyMutationInput!, where: ProblemWhereInput): AffectedRowsOutput!
  updateMovie(data: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie
  updateNativeTypeModel(data: NativeTypeModelUpdateInput!, where: NativeTypeModelWhereUniqueInput!): NativeTypeModel
  updatePatient(data: PatientUpdateInput!, where: PatientWhereUniqueInput!): Patient
  updateProblem(data: ProblemUpdateInput!, where: ProblemWhereUniqueInput!): Problem
  upsertClient(create: ClientCreateInput!, update: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client!
  upsertCreator(create: CreatorCreateInput!, update: CreatorUpdateInput!, where: CreatorWhereUniqueInput!): Creator!
  upsertDirector(create: DirectorCreateInput!, update: DirectorUpdateInput!, where: DirectorWhereUniqueInput!): Director!
  upsertMovie(create: MovieCreateInput!, update: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie!
  upsertNativeTypeModel(create: NativeTypeModelCreateInput!, update: NativeTypeModelUpdateInput!, where: NativeTypeModelWhereUniqueInput!): NativeTypeModel!
  upsertPatient(create: PatientCreateInput!, update: PatientUpdateInput!, where: PatientWhereUniqueInput!): Patient!
  upsertProblem(create: ProblemCreateInput!, update: ProblemUpdateInput!, where: ProblemWhereUniqueInput!): Problem!
}

type NativeTypeModel {
  bigInt: BigInt
  byteA: Byte
  decimal: Decimal
  id: Int!
}

type NativeTypeModelAvgAggregate {
  bigInt: Float
  decimal: Decimal
  id: Float
}

input NativeTypeModelAvgOrderByAggregateInput {
  bigInt: SortOrder
  decimal: SortOrder
  id: SortOrder
}

type NativeTypeModelCountAggregate {
  _all: Int!
  bigInt: Int!
  byteA: Int!
  decimal: Int!
  id: Int!
}

input NativeTypeModelCountOrderByAggregateInput {
  bigInt: SortOrder
  byteA: SortOrder
  decimal: SortOrder
  id: SortOrder
}

input NativeTypeModelCreateInput {
  bigInt: BigInt
  byteA: Byte
  decimal: Decimal
}

input NativeTypeModelCreateManyInput {
  bigInt: BigInt
  byteA: Byte
  decimal: Decimal
  id: Int
}

type NativeTypeModelGroupBy {
  _avg: NativeTypeModelAvgAggregate
  _count: NativeTypeModelCountAggregate
  _max: NativeTypeModelMaxAggregate
  _min: NativeTypeModelMinAggregate
  _sum: NativeTypeModelSumAggregate
  bigInt: BigInt
  byteA: Byte
  decimal: Decimal
  id: Int!
}

type NativeTypeModelMaxAggregate {
  bigInt: BigInt
  byteA: Byte
  decimal: Decimal
  id: Int
}

input NativeTypeModelMaxOrderByAggregateInput {
  bigInt: SortOrder
  byteA: SortOrder
  decimal: SortOrder
  id: SortOrder
}

type NativeTypeModelMinAggregate {
  bigInt: BigInt
  byteA: Byte
  decimal: Decimal
  id: Int
}

input NativeTypeModelMinOrderByAggregateInput {
  bigInt: SortOrder
  byteA: SortOrder
  decimal: SortOrder
  id: SortOrder
}

input NativeTypeModelOrderByWithAggregationInput {
  _avg: NativeTypeModelAvgOrderByAggregateInput
  _count: NativeTypeModelCountOrderByAggregateInput
  _max: NativeTypeModelMaxOrderByAggregateInput
  _min: NativeTypeModelMinOrderByAggregateInput
  _sum: NativeTypeModelSumOrderByAggregateInput
  bigInt: SortOrder
  byteA: SortOrder
  decimal: SortOrder
  id: SortOrder
}

input NativeTypeModelOrderByWithRelationInput {
  bigInt: SortOrder
  byteA: SortOrder
  decimal: SortOrder
  id: SortOrder
}

enum NativeTypeModelScalarFieldEnum {
  bigInt
  byteA
  decimal
  id
}

input NativeTypeModelScalarWhereWithAggregatesInput {
  AND: [NativeTypeModelScalarWhereWithAggregatesInput!]
  NOT: [NativeTypeModelScalarWhereWithAggregatesInput!]
  OR: [NativeTypeModelScalarWhereWithAggregatesInput!]
  bigInt: BigIntNullableWithAggregatesFilter
  byteA: BytesNullableWithAggregatesFilter
  decimal: DecimalNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
}

type NativeTypeModelSumAggregate {
  bigInt: BigInt
  decimal: Decimal
  id: Int
}

input NativeTypeModelSumOrderByAggregateInput {
  bigInt: SortOrder
  decimal: SortOrder
  id: SortOrder
}

input NativeTypeModelUpdateInput {
  bigInt: NullableBigIntFieldUpdateOperationsInput
  byteA: NullableBytesFieldUpdateOperationsInput
  decimal: NullableDecimalFieldUpdateOperationsInput
}

input NativeTypeModelUpdateManyMutationInput {
  bigInt: NullableBigIntFieldUpdateOperationsInput
  byteA: NullableBytesFieldUpdateOperationsInput
  decimal: NullableDecimalFieldUpdateOperationsInput
}

input NativeTypeModelWhereInput {
  AND: [NativeTypeModelWhereInput!]
  NOT: [NativeTypeModelWhereInput!]
  OR: [NativeTypeModelWhereInput!]
  bigInt: BigIntNullableFilter
  byteA: BytesNullableFilter
  decimal: DecimalNullableFilter
  id: IntFilter
}

input NativeTypeModelWhereUniqueInput {
  id: Int
}

input NestedBigIntNullableFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntNullableFilter
  notIn: [BigInt!]
}

input NestedBigIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedBigIntNullableFilter
  _min: NestedBigIntNullableFilter
  _sum: NestedBigIntNullableFilter
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntNullableWithAggregatesFilter
  notIn: [BigInt!]
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedBytesNullableFilter {
  equals: Byte
  not: NestedBytesNullableFilter
}

input NestedBytesNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedBytesNullableFilter
  _min: NestedBytesNullableFilter
  equals: Byte
  not: NestedBytesNullableWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDecimalNullableFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableFilter
  notIn: [Decimal!]
}

input NestedDecimalNullableWithAggregatesFilter {
  _avg: NestedDecimalNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedDecimalNullableFilter
  _min: NestedDecimalNullableFilter
  _sum: NestedDecimalNullableFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableWithAggregatesFilter
  notIn: [Decimal!]
}

input NestedEnumPostKindNullableFilter {
  equals: PostKind
  in: [PostKind!]
  not: NestedEnumPostKindNullableFilter
  notIn: [PostKind!]
}

input NestedEnumPostKindNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedEnumPostKindNullableFilter
  _min: NestedEnumPostKindNullableFilter
  equals: PostKind
  in: [PostKind!]
  not: NestedEnumPostKindNullableWithAggregatesFilter
  notIn: [PostKind!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedJsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableBigIntFieldUpdateOperationsInput {
  decrement: BigInt
  divide: BigInt
  increment: BigInt
  multiply: BigInt
  set: BigInt
}

input NullableBytesFieldUpdateOperationsInput {
  set: Byte
}

input NullableDecimalFieldUpdateOperationsInput {
  decrement: Decimal
  divide: Decimal
  increment: Decimal
  multiply: Decimal
  set: Decimal
}

input NullableEnumPostKindFieldUpdateOperationsInput {
  set: PostKind
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Patient {
  email: String!
  firstName: String!
  lastName: String!
}

type PatientCountAggregate {
  _all: Int!
  email: Int!
  firstName: Int!
  lastName: Int!
}

input PatientCountOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
}

input PatientCreateInput {
  email: String!
  firstName: String!
  lastName: String!
}

input PatientCreateManyInput {
  email: String!
  firstName: String!
  lastName: String!
}

input PatientFirstNameLastNameCompoundUniqueInput {
  firstName: String!
  lastName: String!
}

type PatientGroupBy {
  _count: PatientCountAggregate
  _max: PatientMaxAggregate
  _min: PatientMinAggregate
  email: String!
  firstName: String!
  lastName: String!
}

type PatientMaxAggregate {
  email: String
  firstName: String
  lastName: String
}

input PatientMaxOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
}

type PatientMinAggregate {
  email: String
  firstName: String
  lastName: String
}

input PatientMinOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
}

input PatientOrderByWithAggregationInput {
  _count: PatientCountOrderByAggregateInput
  _max: PatientMaxOrderByAggregateInput
  _min: PatientMinOrderByAggregateInput
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
}

input PatientOrderByWithRelationInput {
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
}

enum PatientScalarFieldEnum {
  email
  firstName
  lastName
}

input PatientScalarWhereWithAggregatesInput {
  AND: [PatientScalarWhereWithAggregatesInput!]
  NOT: [PatientScalarWhereWithAggregatesInput!]
  OR: [PatientScalarWhereWithAggregatesInput!]
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
}

input PatientUpdateInput {
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input PatientUpdateManyMutationInput {
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input PatientWhereInput {
  AND: [PatientWhereInput!]
  NOT: [PatientWhereInput!]
  OR: [PatientWhereInput!]
  email: StringFilter
  firstName: StringFilter
  lastName: StringFilter
}

input PatientWhereUniqueInput {
  firstName_lastName: PatientFirstNameLastNameCompoundUniqueInput
}

type Post {
  author: Client!
  authorId: Int!
  content: String
  createdAt: DateTime!
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  title: String!
  updatedAt: DateTime!
  uuid: String!
}

type PostAvgAggregate {
  authorId: Float
  editorId: Float
}

input PostAvgOrderByAggregateInput {
  authorId: SortOrder
  editorId: SortOrder
}

type PostCountAggregate {
  _all: Int!
  authorId: Int!
  content: Int!
  createdAt: Int!
  editorId: Int!
  kind: Int!
  metadata: Int!
  published: Int!
  subtitle: Int!
  title: Int!
  updatedAt: Int!
  uuid: Int!
}

input PostCountOrderByAggregateInput {
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  editorId: SortOrder
  kind: SortOrder
  metadata: SortOrder
  published: SortOrder
  subtitle: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  uuid: SortOrder
}

input PostCreateInput {
  author: ClientCreateNestedOneWithoutPostsInput!
  content: String
  createdAt: DateTime
  editor: ClientCreateNestedOneWithoutEditorPostsInput
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  subtitle: String!
  title: String!
  updatedAt: DateTime
  uuid: String
}

input PostCreateManyAuthorInput {
  content: String
  createdAt: DateTime
  editorId: Int
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  subtitle: String!
  title: String!
  updatedAt: DateTime
  uuid: String
}

input PostCreateManyAuthorInputEnvelope {
  data: [PostCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input PostCreateManyEditorInput {
  authorId: Int!
  content: String
  createdAt: DateTime
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  subtitle: String!
  title: String!
  updatedAt: DateTime
  uuid: String
}

input PostCreateManyEditorInputEnvelope {
  data: [PostCreateManyEditorInput!]!
  skipDuplicates: Boolean
}

input PostCreateNestedManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
  create: [PostCreateWithoutAuthorInput!]
  createMany: PostCreateManyAuthorInputEnvelope
}

input PostCreateNestedManyWithoutEditorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutEditorInput!]
  create: [PostCreateWithoutEditorInput!]
  createMany: PostCreateManyEditorInputEnvelope
}

input PostCreateOrConnectWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostCreateOrConnectWithoutEditorInput {
  create: PostCreateWithoutEditorInput!
  where: PostWhereUniqueInput!
}

input PostCreateWithoutAuthorInput {
  content: String
  createdAt: DateTime
  editor: ClientCreateNestedOneWithoutEditorPostsInput
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  subtitle: String!
  title: String!
  updatedAt: DateTime
  uuid: String
}

input PostCreateWithoutEditorInput {
  author: ClientCreateNestedOneWithoutPostsInput!
  content: String
  createdAt: DateTime
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  subtitle: String!
  title: String!
  updatedAt: DateTime
  uuid: String
}

type PostGroupBy {
  _avg: PostAvgAggregate
  _count: PostCountAggregate
  _max: PostMaxAggregate
  _min: PostMinAggregate
  _sum: PostSumAggregate
  authorId: Int!
  content: String
  createdAt: DateTime!
  editorId: Int
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  subtitle: String!
  title: String!
  updatedAt: DateTime!
  uuid: String!
}

enum PostKind {
  ADVERT
  BLOG
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

type PostMaxAggregate {
  authorId: Int
  content: String
  createdAt: DateTime
  editorId: Int
  kind: PostKind
  published: Boolean
  subtitle: String
  title: String
  updatedAt: DateTime
  uuid: String
}

input PostMaxOrderByAggregateInput {
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  editorId: SortOrder
  kind: SortOrder
  published: SortOrder
  subtitle: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  uuid: SortOrder
}

type PostMinAggregate {
  authorId: Int
  content: String
  createdAt: DateTime
  editorId: Int
  kind: PostKind
  published: Boolean
  subtitle: String
  title: String
  updatedAt: DateTime
  uuid: String
}

input PostMinOrderByAggregateInput {
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  editorId: SortOrder
  kind: SortOrder
  published: SortOrder
  subtitle: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  uuid: SortOrder
}

input PostOrderByRelationAggregateInput {
  _count: SortOrder
}

input PostOrderByWithAggregationInput {
  _avg: PostAvgOrderByAggregateInput
  _count: PostCountOrderByAggregateInput
  _max: PostMaxOrderByAggregateInput
  _min: PostMinOrderByAggregateInput
  _sum: PostSumOrderByAggregateInput
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  editorId: SortOrder
  kind: SortOrder
  metadata: SortOrder
  published: SortOrder
  subtitle: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  uuid: SortOrder
}

input PostOrderByWithRelationInput {
  author: ClientOrderByWithRelationInput
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  editor: ClientOrderByWithRelationInput
  editorId: SortOrder
  kind: SortOrder
  metadata: SortOrder
  published: SortOrder
  subtitle: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  uuid: SortOrder
}

enum PostScalarFieldEnum {
  authorId
  content
  createdAt
  editorId
  kind
  metadata
  published
  subtitle
  title
  updatedAt
  uuid
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  authorId: IntFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  editorId: IntNullableFilter
  kind: EnumPostKindNullableFilter
  metadata: JsonFilter
  published: BoolFilter
  subtitle: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  uuid: StringFilter
}

input PostScalarWhereWithAggregatesInput {
  AND: [PostScalarWhereWithAggregatesInput!]
  NOT: [PostScalarWhereWithAggregatesInput!]
  OR: [PostScalarWhereWithAggregatesInput!]
  authorId: IntWithAggregatesFilter
  content: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  editorId: IntNullableWithAggregatesFilter
  kind: EnumPostKindNullableWithAggregatesFilter
  metadata: JsonWithAggregatesFilter
  published: BoolWithAggregatesFilter
  subtitle: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  uuid: StringWithAggregatesFilter
}

type PostSumAggregate {
  authorId: Int
  editorId: Int
}

input PostSumOrderByAggregateInput {
  authorId: SortOrder
  editorId: SortOrder
}

input PostUpdateManyMutationInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  kind: NullableEnumPostKindFieldUpdateOperationsInput
  metadata: JSON
  published: BoolFieldUpdateOperationsInput
  subtitle: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  uuid: StringFieldUpdateOperationsInput
}

input PostUpdateManyWithWhereWithoutAuthorInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithWhereWithoutEditorInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
  create: [PostCreateWithoutAuthorInput!]
  createMany: PostCreateManyAuthorInputEnvelope
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [PostUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input PostUpdateManyWithoutEditorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutEditorInput!]
  create: [PostCreateWithoutEditorInput!]
  createMany: PostCreateManyEditorInputEnvelope
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutEditorInput!]
  updateMany: [PostUpdateManyWithWhereWithoutEditorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutEditorInput!]
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  data: PostUpdateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithWhereUniqueWithoutEditorInput {
  data: PostUpdateWithoutEditorInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithoutAuthorInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  editor: ClientUpdateOneWithoutEditorPostsInput
  kind: NullableEnumPostKindFieldUpdateOperationsInput
  metadata: JSON
  published: BoolFieldUpdateOperationsInput
  subtitle: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  uuid: StringFieldUpdateOperationsInput
}

input PostUpdateWithoutEditorInput {
  author: ClientUpdateOneRequiredWithoutPostsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  kind: NullableEnumPostKindFieldUpdateOperationsInput
  metadata: JSON
  published: BoolFieldUpdateOperationsInput
  subtitle: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  uuid: StringFieldUpdateOperationsInput
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  update: PostUpdateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithWhereUniqueWithoutEditorInput {
  create: PostCreateWithoutEditorInput!
  update: PostUpdateWithoutEditorInput!
  where: PostWhereUniqueInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  author: ClientRelationFilter
  authorId: IntFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  editor: ClientRelationFilter
  editorId: IntNullableFilter
  kind: EnumPostKindNullableFilter
  metadata: JsonFilter
  published: BoolFilter
  subtitle: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  uuid: StringFilter
}

input PostWhereUniqueInput {
  uuid: String
}

type Problem {
  _count: ProblemCount
  creator: Creator
  creatorId: Int
  id: Int!
  likedBy(cursor: CreatorWhereUniqueInput, distinct: [CreatorScalarFieldEnum!], orderBy: [CreatorOrderByWithRelationInput!], skip: Int, take: Int, where: CreatorWhereInput): [Creator!]!
  problemText: String!
}

type ProblemAvgAggregate {
  creatorId: Float
  id: Float
}

input ProblemAvgOrderByAggregateInput {
  creatorId: SortOrder
  id: SortOrder
}

type ProblemCount {
  likedBy: Int!
}

type ProblemCountAggregate {
  _all: Int!
  creatorId: Int!
  id: Int!
  problemText: Int!
}

input ProblemCountOrderByAggregateInput {
  creatorId: SortOrder
  id: SortOrder
  problemText: SortOrder
}

input ProblemCreateInput {
  creator: CreatorCreateNestedOneWithoutProblemsInput
  likedBy: CreatorCreateNestedManyWithoutLikesInput
  problemText: String!
}

input ProblemCreateManyCreatorInput {
  id: Int
  problemText: String!
}

input ProblemCreateManyCreatorInputEnvelope {
  data: [ProblemCreateManyCreatorInput!]!
  skipDuplicates: Boolean
}

input ProblemCreateManyInput {
  creatorId: Int
  id: Int
  problemText: String!
}

input ProblemCreateNestedManyWithoutCreatorInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutCreatorInput!]
  create: [ProblemCreateWithoutCreatorInput!]
  createMany: ProblemCreateManyCreatorInputEnvelope
}

input ProblemCreateNestedManyWithoutLikedByInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutLikedByInput!]
  create: [ProblemCreateWithoutLikedByInput!]
}

input ProblemCreateOrConnectWithoutCreatorInput {
  create: ProblemCreateWithoutCreatorInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateOrConnectWithoutLikedByInput {
  create: ProblemCreateWithoutLikedByInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateWithoutCreatorInput {
  likedBy: CreatorCreateNestedManyWithoutLikesInput
  problemText: String!
}

input ProblemCreateWithoutLikedByInput {
  creator: CreatorCreateNestedOneWithoutProblemsInput
  problemText: String!
}

type ProblemGroupBy {
  _avg: ProblemAvgAggregate
  _count: ProblemCountAggregate
  _max: ProblemMaxAggregate
  _min: ProblemMinAggregate
  _sum: ProblemSumAggregate
  creatorId: Int
  id: Int!
  problemText: String!
}

input ProblemListRelationFilter {
  every: ProblemWhereInput
  none: ProblemWhereInput
  some: ProblemWhereInput
}

type ProblemMaxAggregate {
  creatorId: Int
  id: Int
  problemText: String
}

input ProblemMaxOrderByAggregateInput {
  creatorId: SortOrder
  id: SortOrder
  problemText: SortOrder
}

type ProblemMinAggregate {
  creatorId: Int
  id: Int
  problemText: String
}

input ProblemMinOrderByAggregateInput {
  creatorId: SortOrder
  id: SortOrder
  problemText: SortOrder
}

input ProblemOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProblemOrderByWithAggregationInput {
  _avg: ProblemAvgOrderByAggregateInput
  _count: ProblemCountOrderByAggregateInput
  _max: ProblemMaxOrderByAggregateInput
  _min: ProblemMinOrderByAggregateInput
  _sum: ProblemSumOrderByAggregateInput
  creatorId: SortOrder
  id: SortOrder
  problemText: SortOrder
}

input ProblemOrderByWithRelationInput {
  creator: CreatorOrderByWithRelationInput
  creatorId: SortOrder
  id: SortOrder
  likedBy: CreatorOrderByRelationAggregateInput
  problemText: SortOrder
}

enum ProblemScalarFieldEnum {
  creatorId
  id
  problemText
}

input ProblemScalarWhereInput {
  AND: [ProblemScalarWhereInput!]
  NOT: [ProblemScalarWhereInput!]
  OR: [ProblemScalarWhereInput!]
  creatorId: IntNullableFilter
  id: IntFilter
  problemText: StringFilter
}

input ProblemScalarWhereWithAggregatesInput {
  AND: [ProblemScalarWhereWithAggregatesInput!]
  NOT: [ProblemScalarWhereWithAggregatesInput!]
  OR: [ProblemScalarWhereWithAggregatesInput!]
  creatorId: IntNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  problemText: StringWithAggregatesFilter
}

type ProblemSumAggregate {
  creatorId: Int
  id: Int
}

input ProblemSumOrderByAggregateInput {
  creatorId: SortOrder
  id: SortOrder
}

input ProblemUpdateInput {
  creator: CreatorUpdateOneWithoutProblemsInput
  likedBy: CreatorUpdateManyWithoutLikesInput
  problemText: StringFieldUpdateOperationsInput
}

input ProblemUpdateManyMutationInput {
  problemText: StringFieldUpdateOperationsInput
}

input ProblemUpdateManyWithWhereWithoutCreatorInput {
  data: ProblemUpdateManyMutationInput!
  where: ProblemScalarWhereInput!
}

input ProblemUpdateManyWithWhereWithoutLikedByInput {
  data: ProblemUpdateManyMutationInput!
  where: ProblemScalarWhereInput!
}

input ProblemUpdateManyWithoutCreatorInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutCreatorInput!]
  create: [ProblemCreateWithoutCreatorInput!]
  createMany: ProblemCreateManyCreatorInputEnvelope
  delete: [ProblemWhereUniqueInput!]
  deleteMany: [ProblemScalarWhereInput!]
  disconnect: [ProblemWhereUniqueInput!]
  set: [ProblemWhereUniqueInput!]
  update: [ProblemUpdateWithWhereUniqueWithoutCreatorInput!]
  updateMany: [ProblemUpdateManyWithWhereWithoutCreatorInput!]
  upsert: [ProblemUpsertWithWhereUniqueWithoutCreatorInput!]
}

input ProblemUpdateManyWithoutLikedByInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutLikedByInput!]
  create: [ProblemCreateWithoutLikedByInput!]
  delete: [ProblemWhereUniqueInput!]
  deleteMany: [ProblemScalarWhereInput!]
  disconnect: [ProblemWhereUniqueInput!]
  set: [ProblemWhereUniqueInput!]
  update: [ProblemUpdateWithWhereUniqueWithoutLikedByInput!]
  updateMany: [ProblemUpdateManyWithWhereWithoutLikedByInput!]
  upsert: [ProblemUpsertWithWhereUniqueWithoutLikedByInput!]
}

input ProblemUpdateWithWhereUniqueWithoutCreatorInput {
  data: ProblemUpdateWithoutCreatorInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpdateWithWhereUniqueWithoutLikedByInput {
  data: ProblemUpdateWithoutLikedByInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpdateWithoutCreatorInput {
  likedBy: CreatorUpdateManyWithoutLikesInput
  problemText: StringFieldUpdateOperationsInput
}

input ProblemUpdateWithoutLikedByInput {
  creator: CreatorUpdateOneWithoutProblemsInput
  problemText: StringFieldUpdateOperationsInput
}

input ProblemUpsertWithWhereUniqueWithoutCreatorInput {
  create: ProblemCreateWithoutCreatorInput!
  update: ProblemUpdateWithoutCreatorInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpsertWithWhereUniqueWithoutLikedByInput {
  create: ProblemCreateWithoutLikedByInput!
  update: ProblemUpdateWithoutLikedByInput!
  where: ProblemWhereUniqueInput!
}

input ProblemWhereInput {
  AND: [ProblemWhereInput!]
  NOT: [ProblemWhereInput!]
  OR: [ProblemWhereInput!]
  creator: CreatorRelationFilter
  creatorId: IntNullableFilter
  id: IntFilter
  likedBy: CreatorListRelationFilter
  problemText: StringFilter
}

input ProblemWhereUniqueInput {
  id: Int
}

type Query {
  aggregateClient(cursor: ClientWhereUniqueInput, orderBy: [ClientOrderByWithRelationInput!], skip: Int, take: Int, where: ClientWhereInput): AggregateClient!
  aggregateCreator(cursor: CreatorWhereUniqueInput, orderBy: [CreatorOrderByWithRelationInput!], skip: Int, take: Int, where: CreatorWhereInput): AggregateCreator!
  aggregateDirector(cursor: DirectorWhereUniqueInput, orderBy: [DirectorOrderByWithRelationInput!], skip: Int, take: Int, where: DirectorWhereInput): AggregateDirector!
  aggregateMovie(cursor: MovieWhereUniqueInput, orderBy: [MovieOrderByWithRelationInput!], skip: Int, take: Int, where: MovieWhereInput): AggregateMovie!
  aggregateNativeTypeModel(cursor: NativeTypeModelWhereUniqueInput, orderBy: [NativeTypeModelOrderByWithRelationInput!], skip: Int, take: Int, where: NativeTypeModelWhereInput): AggregateNativeTypeModel!
  aggregatePatient(cursor: PatientWhereUniqueInput, orderBy: [PatientOrderByWithRelationInput!], skip: Int, take: Int, where: PatientWhereInput): AggregatePatient!
  aggregateProblem(cursor: ProblemWhereUniqueInput, orderBy: [ProblemOrderByWithRelationInput!], skip: Int, take: Int, where: ProblemWhereInput): AggregateProblem!
  allClients: [Client!]!
  allPosts: [Post!]!
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  client(where: ClientWhereUniqueInput!): Client
  clients(cursor: ClientWhereUniqueInput, distinct: [ClientScalarFieldEnum!], orderBy: [ClientOrderByWithRelationInput!], skip: Int, take: Int, where: ClientWhereInput): [Client!]!
  creator(where: CreatorWhereUniqueInput!): Creator
  creators(cursor: CreatorWhereUniqueInput, distinct: [CreatorScalarFieldEnum!], orderBy: [CreatorOrderByWithRelationInput!], skip: Int, take: Int, where: CreatorWhereInput): [Creator!]!
  customFindClientsWithArgs(cursor: ClientWhereUniqueInput, distinct: [ClientScalarFieldEnum!], orderBy: [ClientOrderByWithRelationInput!], skip: Int, take: Int, where: ClientWhereInput): [Client!]!
  director(where: DirectorWhereUniqueInput!): Director
  directors(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByWithRelationInput!], skip: Int, take: Int, where: DirectorWhereInput): [Director!]!
  findFirstClient(cursor: ClientWhereUniqueInput, distinct: [ClientScalarFieldEnum!], orderBy: [ClientOrderByWithRelationInput!], skip: Int, take: Int, where: ClientWhereInput): Client
  findFirstCreator(cursor: CreatorWhereUniqueInput, distinct: [CreatorScalarFieldEnum!], orderBy: [CreatorOrderByWithRelationInput!], skip: Int, take: Int, where: CreatorWhereInput): Creator
  findFirstDirector(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByWithRelationInput!], skip: Int, take: Int, where: DirectorWhereInput): Director
  findFirstMovie(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationInput!], skip: Int, take: Int, where: MovieWhereInput): Movie
  findFirstNativeTypeModel(cursor: NativeTypeModelWhereUniqueInput, distinct: [NativeTypeModelScalarFieldEnum!], orderBy: [NativeTypeModelOrderByWithRelationInput!], skip: Int, take: Int, where: NativeTypeModelWhereInput): NativeTypeModel
  findFirstPatient(cursor: PatientWhereUniqueInput, distinct: [PatientScalarFieldEnum!], orderBy: [PatientOrderByWithRelationInput!], skip: Int, take: Int, where: PatientWhereInput): Patient
  findFirstProblem(cursor: ProblemWhereUniqueInput, distinct: [ProblemScalarFieldEnum!], orderBy: [ProblemOrderByWithRelationInput!], skip: Int, take: Int, where: ProblemWhereInput): Problem
  groupByCategory(by: [CategoryScalarFieldEnum!]!, having: CategoryScalarWhereWithAggregatesInput, orderBy: [CategoryOrderByWithAggregationInput!], skip: Int, take: Int, where: CategoryWhereInput): [CategoryGroupBy!]!
  groupByClient(by: [ClientScalarFieldEnum!]!, having: ClientScalarWhereWithAggregatesInput, orderBy: [ClientOrderByWithAggregationInput!], skip: Int, take: Int, where: ClientWhereInput): [ClientGroupBy!]!
  groupByCreator(by: [CreatorScalarFieldEnum!]!, having: CreatorScalarWhereWithAggregatesInput, orderBy: [CreatorOrderByWithAggregationInput!], skip: Int, take: Int, where: CreatorWhereInput): [CreatorGroupBy!]!
  groupByDirector(by: [DirectorScalarFieldEnum!]!, having: DirectorScalarWhereWithAggregatesInput, orderBy: [DirectorOrderByWithAggregationInput!], skip: Int, take: Int, where: DirectorWhereInput): [DirectorGroupBy!]!
  groupByMovie(by: [MovieScalarFieldEnum!]!, having: MovieScalarWhereWithAggregatesInput, orderBy: [MovieOrderByWithAggregationInput!], skip: Int, take: Int, where: MovieWhereInput): [MovieGroupBy!]!
  groupByNativeTypeModel(by: [NativeTypeModelScalarFieldEnum!]!, having: NativeTypeModelScalarWhereWithAggregatesInput, orderBy: [NativeTypeModelOrderByWithAggregationInput!], skip: Int, take: Int, where: NativeTypeModelWhereInput): [NativeTypeModelGroupBy!]!
  groupByPatient(by: [PatientScalarFieldEnum!]!, having: PatientScalarWhereWithAggregatesInput, orderBy: [PatientOrderByWithAggregationInput!], skip: Int, take: Int, where: PatientWhereInput): [PatientGroupBy!]!
  groupByPost(by: [PostScalarFieldEnum!]!, having: PostScalarWhereWithAggregatesInput, orderBy: [PostOrderByWithAggregationInput!], skip: Int, take: Int, where: PostWhereInput): [PostGroupBy!]!
  groupByProblem(by: [ProblemScalarFieldEnum!]!, having: ProblemScalarWhereWithAggregatesInput, orderBy: [ProblemOrderByWithAggregationInput!], skip: Int, take: Int, where: ProblemWhereInput): [ProblemGroupBy!]!
  movie(where: MovieWhereUniqueInput!): Movie
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
  nativeTypeModel(where: NativeTypeModelWhereUniqueInput!): NativeTypeModel
  nativeTypeModels(cursor: NativeTypeModelWhereUniqueInput, distinct: [NativeTypeModelScalarFieldEnum!], orderBy: [NativeTypeModelOrderByWithRelationInput!], skip: Int, take: Int, where: NativeTypeModelWhereInput): [NativeTypeModel!]!
  patient(where: PatientWhereUniqueInput!): Patient
  patients(cursor: PatientWhereUniqueInput, distinct: [PatientScalarFieldEnum!], orderBy: [PatientOrderByWithRelationInput!], skip: Int, take: Int, where: PatientWhereInput): [Patient!]!
  post(where: PostWhereUniqueInput!): Post
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  problem(where: ProblemWhereUniqueInput!): Problem
  problems(cursor: ProblemWhereUniqueInput, distinct: [ProblemScalarFieldEnum!], orderBy: [ProblemOrderByWithRelationInput!], skip: Int, take: Int, where: ProblemWhereInput): [Problem!]!
}

enum QueryMode {
  default
  insensitive
}

"""Role enum doc"""
enum Role {
  ADMIN
  USER
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}
