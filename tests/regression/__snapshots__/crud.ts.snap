// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`crud should properly generate actions resolver classes for prisma model: CreateManyUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class CreateManyUserResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: CreateOneUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { CreateOneUserArgs } from \\"./args/CreateOneUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class CreateOneUserResolver {
  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false
  })
  async createOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateOneUserArgs): Promise<User> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: DeleteManyUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class DeleteManyUserResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: DeleteOneUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { DeleteOneUserArgs } from \\"./args/DeleteOneUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class DeleteOneUserResolver {
  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true
  })
  async deleteOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteOneUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindFirstUserOrThrowResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindFirstUserOrThrowArgs } from \\"./args/FindFirstUserOrThrowArgs\\";
import { User } from \\"../../../models/User\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class FindFirstUserOrThrowResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findFirstUserOrThrow(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstUserOrThrowArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirstOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindFirstUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class FindFirstUserResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findFirstUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindManyUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class FindManyUserResolver {
  @TypeGraphQL.Query(_returns => [User], {
    nullable: false
  })
  async users(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyUserArgs): Promise<User[]> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindUniqueUserOrThrowResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindUniqueUserOrThrowArgs } from \\"./args/FindUniqueUserOrThrowArgs\\";
import { User } from \\"../../../models/User\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class FindUniqueUserOrThrowResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async getUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUserOrThrowArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUniqueOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindUniqueUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class FindUniqueUserResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async user(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: GroupByUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { User } from \\"../../../models/User\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class GroupByUserResolver {
  @TypeGraphQL.Query(_returns => [UserGroupBy], {
    nullable: false
  })
  async groupByUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByUserArgs): Promise<UserGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: Index 1`] = `
"export * from \\"./resolvers-actions.index\\";
export * from \\"./resolvers-crud.index\\";
export * from \\"./args.index\\";
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: UpdateManyUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class UpdateManyUserResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: UpdateOneUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { UpdateOneUserArgs } from \\"./args/UpdateOneUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class UpdateOneUserResolver {
  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true
  })
  async updateOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateOneUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: UpsertOneUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { UpsertOneUserArgs } from \\"./args/UpsertOneUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class UpsertOneUserResolver {
  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false
  })
  async upsertOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertOneUserArgs): Promise<User> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: actionsIndex 1`] = `
"export { AggregateUserResolver } from \\"./User/AggregateUserResolver\\";
export { CreateManyUserResolver } from \\"./User/CreateManyUserResolver\\";
export { CreateOneUserResolver } from \\"./User/CreateOneUserResolver\\";
export { DeleteManyUserResolver } from \\"./User/DeleteManyUserResolver\\";
export { DeleteOneUserResolver } from \\"./User/DeleteOneUserResolver\\";
export { FindFirstUserResolver } from \\"./User/FindFirstUserResolver\\";
export { FindFirstUserOrThrowResolver } from \\"./User/FindFirstUserOrThrowResolver\\";
export { FindManyUserResolver } from \\"./User/FindManyUserResolver\\";
export { FindUniqueUserResolver } from \\"./User/FindUniqueUserResolver\\";
export { FindUniqueUserOrThrowResolver } from \\"./User/FindUniqueUserOrThrowResolver\\";
export { GroupByUserResolver } from \\"./User/GroupByUserResolver\\";
export { UpdateManyUserResolver } from \\"./User/UpdateManyUserResolver\\";
export { UpdateOneUserResolver } from \\"./User/UpdateOneUserResolver\\";
export { UpsertOneUserResolver } from \\"./User/UpsertOneUserResolver\\";
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: argsIndex 1`] = `
"export * from \\"./User/args\\";
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: crudIndex 1`] = `
"export { UserCrudResolver } from \\"./User/UserCrudResolver\\";
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: AggregateUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserOrderByWithRelationInput } from \\"../../../inputs/UserOrderByWithRelationInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class AggregateUserArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UserOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: UserOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: true
  })
  cursor?: UserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: CreateManyUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserCreateManyInput } from \\"../../../inputs/UserCreateManyInput\\";

@TypeGraphQL.ArgsType()
export class CreateManyUserArgs {
  @TypeGraphQL.Field(_type => [UserCreateManyInput], {
    nullable: false
  })
  data!: UserCreateManyInput[];

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  skipDuplicates?: boolean | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: CreateOneUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserCreateInput } from \\"../../../inputs/UserCreateInput\\";

@TypeGraphQL.ArgsType()
export class CreateOneUserArgs {
  @TypeGraphQL.Field(_type => UserCreateInput, {
    nullable: false
  })
  data!: UserCreateInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: DeleteManyUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";

@TypeGraphQL.ArgsType()
export class DeleteManyUserArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: DeleteOneUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class DeleteOneUserArgs {
  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindFirstUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserOrderByWithRelationInput } from \\"../../../inputs/UserOrderByWithRelationInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";
import { UserScalarFieldEnum } from \\"../../../../enums/UserScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindFirstUserArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UserOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: UserOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: true
  })
  cursor?: UserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [UserScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindFirstUserOrThrowArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserOrderByWithRelationInput } from \\"../../../inputs/UserOrderByWithRelationInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";
import { UserScalarFieldEnum } from \\"../../../../enums/UserScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindFirstUserOrThrowArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UserOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: UserOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: true
  })
  cursor?: UserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [UserScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindManyUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserOrderByWithRelationInput } from \\"../../../inputs/UserOrderByWithRelationInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";
import { UserScalarFieldEnum } from \\"../../../../enums/UserScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindManyUserArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UserOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: UserOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: true
  })
  cursor?: UserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [UserScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindUniqueUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class FindUniqueUserArgs {
  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindUniqueUserOrThrowArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class FindUniqueUserOrThrowArgs {
  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: GroupByUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserOrderByWithAggregationInput } from \\"../../../inputs/UserOrderByWithAggregationInput\\";
import { UserScalarWhereWithAggregatesInput } from \\"../../../inputs/UserScalarWhereWithAggregatesInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";
import { UserScalarFieldEnum } from \\"../../../../enums/UserScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class GroupByUserArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UserOrderByWithAggregationInput], {
    nullable: true
  })
  orderBy?: UserOrderByWithAggregationInput[] | undefined;

  @TypeGraphQL.Field(_type => [UserScalarFieldEnum], {
    nullable: false
  })
  by!: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\">;

  @TypeGraphQL.Field(_type => UserScalarWhereWithAggregatesInput, {
    nullable: true
  })
  having?: UserScalarWhereWithAggregatesInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: Index 1`] = `
"export { AggregateUserArgs } from \\"./AggregateUserArgs\\";
export { CreateManyUserArgs } from \\"./CreateManyUserArgs\\";
export { CreateOneUserArgs } from \\"./CreateOneUserArgs\\";
export { DeleteManyUserArgs } from \\"./DeleteManyUserArgs\\";
export { DeleteOneUserArgs } from \\"./DeleteOneUserArgs\\";
export { FindFirstUserArgs } from \\"./FindFirstUserArgs\\";
export { FindFirstUserOrThrowArgs } from \\"./FindFirstUserOrThrowArgs\\";
export { FindManyUserArgs } from \\"./FindManyUserArgs\\";
export { FindUniqueUserArgs } from \\"./FindUniqueUserArgs\\";
export { FindUniqueUserOrThrowArgs } from \\"./FindUniqueUserOrThrowArgs\\";
export { GroupByUserArgs } from \\"./GroupByUserArgs\\";
export { UpdateManyUserArgs } from \\"./UpdateManyUserArgs\\";
export { UpdateOneUserArgs } from \\"./UpdateOneUserArgs\\";
export { UpsertOneUserArgs } from \\"./UpsertOneUserArgs\\";
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: UpdateManyUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUpdateManyMutationInput } from \\"../../../inputs/UserUpdateManyMutationInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";

@TypeGraphQL.ArgsType()
export class UpdateManyUserArgs {
  @TypeGraphQL.Field(_type => UserUpdateManyMutationInput, {
    nullable: false
  })
  data!: UserUpdateManyMutationInput;

  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: UpdateOneUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUpdateInput } from \\"../../../inputs/UserUpdateInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpdateOneUserArgs {
  @TypeGraphQL.Field(_type => UserUpdateInput, {
    nullable: false
  })
  data!: UserUpdateInput;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: UpsertOneUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserCreateInput } from \\"../../../inputs/UserCreateInput\\";
import { UserUpdateInput } from \\"../../../inputs/UserUpdateInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpsertOneUserArgs {
  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;

  @TypeGraphQL.Field(_type => UserCreateInput, {
    nullable: false
  })
  create!: UserCreateInput;

  @TypeGraphQL.Field(_type => UserUpdateInput, {
    nullable: false
  })
  update!: UserUpdateInput;
}
"
`;

exports[`crud should properly generate args classes for group by action using aggregate input: GroupBySampleArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { SampleOrderByWithAggregationInput } from \\"../../../inputs/SampleOrderByWithAggregationInput\\";
import { SampleScalarWhereWithAggregatesInput } from \\"../../../inputs/SampleScalarWhereWithAggregatesInput\\";
import { SampleWhereInput } from \\"../../../inputs/SampleWhereInput\\";
import { SampleScalarFieldEnum } from \\"../../../../enums/SampleScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class GroupBySampleArgs {
  @TypeGraphQL.Field(_type => SampleWhereInput, {
    nullable: true
  })
  where?: SampleWhereInput | undefined;

  @TypeGraphQL.Field(_type => [SampleOrderByWithAggregationInput], {
    nullable: true
  })
  orderBy?: SampleOrderByWithAggregationInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleScalarFieldEnum], {
    nullable: false
  })
  by!: Array<\\"idField\\" | \\"stringField\\" | \\"floatField\\" | \\"intField\\" | \\"booleanField\\" | \\"dateField\\" | \\"jsonField\\">;

  @TypeGraphQL.Field(_type => SampleScalarWhereWithAggregatesInput, {
    nullable: true
  })
  having?: SampleScalarWhereWithAggregatesInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud should properly generate args classes for sorting by many-to-many relation fields: AggregateFirstModelArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { FirstModelOrderByWithRelationInput } from \\"../../../inputs/FirstModelOrderByWithRelationInput\\";
import { FirstModelWhereInput } from \\"../../../inputs/FirstModelWhereInput\\";
import { FirstModelWhereUniqueInput } from \\"../../../inputs/FirstModelWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class AggregateFirstModelArgs {
  @TypeGraphQL.Field(_type => FirstModelWhereInput, {
    nullable: true
  })
  where?: FirstModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => [FirstModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: FirstModelOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => FirstModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: FirstModelWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud should properly generate args classes for sorting by many-to-many relation fields: FindFirstFirstModelArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { FirstModelOrderByWithRelationInput } from \\"../../../inputs/FirstModelOrderByWithRelationInput\\";
import { FirstModelWhereInput } from \\"../../../inputs/FirstModelWhereInput\\";
import { FirstModelWhereUniqueInput } from \\"../../../inputs/FirstModelWhereUniqueInput\\";
import { FirstModelScalarFieldEnum } from \\"../../../../enums/FirstModelScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindFirstFirstModelArgs {
  @TypeGraphQL.Field(_type => FirstModelWhereInput, {
    nullable: true
  })
  where?: FirstModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => [FirstModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: FirstModelOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => FirstModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: FirstModelWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [FirstModelScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"idField\\" | \\"uniqueStringField\\" | \\"floatField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for sorting by many-to-many relation fields: FindManyFirstModelArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { FirstModelOrderByWithRelationInput } from \\"../../../inputs/FirstModelOrderByWithRelationInput\\";
import { FirstModelWhereInput } from \\"../../../inputs/FirstModelWhereInput\\";
import { FirstModelWhereUniqueInput } from \\"../../../inputs/FirstModelWhereUniqueInput\\";
import { FirstModelScalarFieldEnum } from \\"../../../../enums/FirstModelScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindManyFirstModelArgs {
  @TypeGraphQL.Field(_type => FirstModelWhereInput, {
    nullable: true
  })
  where?: FirstModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => [FirstModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: FirstModelOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => FirstModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: FirstModelWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [FirstModelScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"idField\\" | \\"uniqueStringField\\" | \\"floatField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for sorting by many-to-many relation fields: index 1`] = `
"export { AggregateFirstModelArgs } from \\"./AggregateFirstModelArgs\\";
export { CreateManyFirstModelArgs } from \\"./CreateManyFirstModelArgs\\";
export { CreateOneFirstModelArgs } from \\"./CreateOneFirstModelArgs\\";
export { DeleteManyFirstModelArgs } from \\"./DeleteManyFirstModelArgs\\";
export { DeleteOneFirstModelArgs } from \\"./DeleteOneFirstModelArgs\\";
export { FindFirstFirstModelArgs } from \\"./FindFirstFirstModelArgs\\";
export { FindFirstFirstModelOrThrowArgs } from \\"./FindFirstFirstModelOrThrowArgs\\";
export { FindManyFirstModelArgs } from \\"./FindManyFirstModelArgs\\";
export { FindUniqueFirstModelArgs } from \\"./FindUniqueFirstModelArgs\\";
export { FindUniqueFirstModelOrThrowArgs } from \\"./FindUniqueFirstModelOrThrowArgs\\";
export { GroupByFirstModelArgs } from \\"./GroupByFirstModelArgs\\";
export { UpdateManyFirstModelArgs } from \\"./UpdateManyFirstModelArgs\\";
export { UpdateOneFirstModelArgs } from \\"./UpdateOneFirstModelArgs\\";
export { UpsertOneFirstModelArgs } from \\"./UpsertOneFirstModelArgs\\";
"
`;

exports[`crud should properly generate args classes for sorting by one-to-many relation fields: AggregateSecondModelArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { SecondModelOrderByWithRelationInput } from \\"../../../inputs/SecondModelOrderByWithRelationInput\\";
import { SecondModelWhereInput } from \\"../../../inputs/SecondModelWhereInput\\";
import { SecondModelWhereUniqueInput } from \\"../../../inputs/SecondModelWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class AggregateSecondModelArgs {
  @TypeGraphQL.Field(_type => SecondModelWhereInput, {
    nullable: true
  })
  where?: SecondModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => [SecondModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: SecondModelOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => SecondModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: SecondModelWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud should properly generate args classes for sorting by one-to-many relation fields: FindFirstSecondModelArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { SecondModelOrderByWithRelationInput } from \\"../../../inputs/SecondModelOrderByWithRelationInput\\";
import { SecondModelWhereInput } from \\"../../../inputs/SecondModelWhereInput\\";
import { SecondModelWhereUniqueInput } from \\"../../../inputs/SecondModelWhereUniqueInput\\";
import { SecondModelScalarFieldEnum } from \\"../../../../enums/SecondModelScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindFirstSecondModelArgs {
  @TypeGraphQL.Field(_type => SecondModelWhereInput, {
    nullable: true
  })
  where?: SecondModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => [SecondModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: SecondModelOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => SecondModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: SecondModelWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [SecondModelScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"idField\\" | \\"uniqueStringField\\" | \\"floatField\\" | \\"firstModelFieldId\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for sorting by one-to-many relation fields: FindManySecondModelArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { SecondModelOrderByWithRelationInput } from \\"../../../inputs/SecondModelOrderByWithRelationInput\\";
import { SecondModelWhereInput } from \\"../../../inputs/SecondModelWhereInput\\";
import { SecondModelWhereUniqueInput } from \\"../../../inputs/SecondModelWhereUniqueInput\\";
import { SecondModelScalarFieldEnum } from \\"../../../../enums/SecondModelScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindManySecondModelArgs {
  @TypeGraphQL.Field(_type => SecondModelWhereInput, {
    nullable: true
  })
  where?: SecondModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => [SecondModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: SecondModelOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => SecondModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: SecondModelWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [SecondModelScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"idField\\" | \\"uniqueStringField\\" | \\"floatField\\" | \\"firstModelFieldId\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for sorting by one-to-many relation fields: index 1`] = `
"export { AggregateSecondModelArgs } from \\"./AggregateSecondModelArgs\\";
export { CreateManySecondModelArgs } from \\"./CreateManySecondModelArgs\\";
export { CreateOneSecondModelArgs } from \\"./CreateOneSecondModelArgs\\";
export { DeleteManySecondModelArgs } from \\"./DeleteManySecondModelArgs\\";
export { DeleteOneSecondModelArgs } from \\"./DeleteOneSecondModelArgs\\";
export { FindFirstSecondModelArgs } from \\"./FindFirstSecondModelArgs\\";
export { FindFirstSecondModelOrThrowArgs } from \\"./FindFirstSecondModelOrThrowArgs\\";
export { FindManySecondModelArgs } from \\"./FindManySecondModelArgs\\";
export { FindUniqueSecondModelArgs } from \\"./FindUniqueSecondModelArgs\\";
export { FindUniqueSecondModelOrThrowArgs } from \\"./FindUniqueSecondModelOrThrowArgs\\";
export { GroupBySecondModelArgs } from \\"./GroupBySecondModelArgs\\";
export { UpdateManySecondModelArgs } from \\"./UpdateManySecondModelArgs\\";
export { UpdateOneSecondModelArgs } from \\"./UpdateOneSecondModelArgs\\";
export { UpsertOneSecondModelArgs } from \\"./UpsertOneSecondModelArgs\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: Index 1`] = `
"export * from \\"./resolvers-actions.index\\";
export * from \\"./resolvers-crud.index\\";
export * from \\"./args.index\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: UserCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUserArgs } from \\"./args/AggregateUserArgs\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { CreateOneUserArgs } from \\"./args/CreateOneUserArgs\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { DeleteOneUserArgs } from \\"./args/DeleteOneUserArgs\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { FindFirstUserOrThrowArgs } from \\"./args/FindFirstUserOrThrowArgs\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { FindUniqueUserOrThrowArgs } from \\"./args/FindUniqueUserOrThrowArgs\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { UpdateOneUserArgs } from \\"./args/UpdateOneUserArgs\\";
import { UpsertOneUserArgs } from \\"./args/UpsertOneUserArgs\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateUser } from \\"../../outputs/AggregateUser\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";

@TypeGraphQL.Resolver(_of => User)
export class UserCrudResolver {
  @TypeGraphQL.Query(_returns => AggregateUser, {
    nullable: false
  })
  async aggregateUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateUserArgs): Promise<AggregateUser> {
    return getPrismaFromContext(ctx).user.aggregate({
      ...args,
      ...transformInfoIntoPrismaArgs(info),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false
  })
  async createOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateOneUserArgs): Promise<User> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true
  })
  async deleteOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteOneUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findFirstUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findFirstUserOrThrow(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstUserOrThrowArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirstOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [User], {
    nullable: false
  })
  async users(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyUserArgs): Promise<User[]> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async user(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async getUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUserOrThrowArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUniqueOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [UserGroupBy], {
    nullable: false
  })
  async groupByUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByUserArgs): Promise<UserGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true
  })
  async updateOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateOneUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false
  })
  async upsertOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertOneUserArgs): Promise<User> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate resolver class for single prisma model: actionsIndex 1`] = `
"export { AggregateUserResolver } from \\"./User/AggregateUserResolver\\";
export { CreateManyUserResolver } from \\"./User/CreateManyUserResolver\\";
export { CreateOneUserResolver } from \\"./User/CreateOneUserResolver\\";
export { DeleteManyUserResolver } from \\"./User/DeleteManyUserResolver\\";
export { DeleteOneUserResolver } from \\"./User/DeleteOneUserResolver\\";
export { FindFirstUserResolver } from \\"./User/FindFirstUserResolver\\";
export { FindFirstUserOrThrowResolver } from \\"./User/FindFirstUserOrThrowResolver\\";
export { FindManyUserResolver } from \\"./User/FindManyUserResolver\\";
export { FindUniqueUserResolver } from \\"./User/FindUniqueUserResolver\\";
export { FindUniqueUserOrThrowResolver } from \\"./User/FindUniqueUserOrThrowResolver\\";
export { GroupByUserResolver } from \\"./User/GroupByUserResolver\\";
export { UpdateManyUserResolver } from \\"./User/UpdateManyUserResolver\\";
export { UpdateOneUserResolver } from \\"./User/UpdateOneUserResolver\\";
export { UpsertOneUserResolver } from \\"./User/UpsertOneUserResolver\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: argsIndex 1`] = `
"export * from \\"./User/args\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: crudIndex 1`] = `
"export { UserCrudResolver } from \\"./User/UserCrudResolver\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: mainIndex 1`] = `
"import * as crudResolversImport from \\"./resolvers/crud/resolvers-crud.index\\";
import { NonEmptyArray } from \\"type-graphql\\";

export * from \\"./enums\\";
export * from \\"./models\\";
export * from \\"./resolvers/crud\\";

export const crudResolvers: NonEmptyArray<Function> = Object.values(crudResolversImport) as unknown as NonEmptyArray<Function>;

export * from \\"./resolvers/inputs\\";
export * from \\"./resolvers/outputs\\";
export * from \\"./enhance\\";
export * from \\"./scalars\\";

export const resolvers = [
  ...crudResolvers,

] as unknown as NonEmptyArray<Function>;
"
`;

exports[`crud should properly generate resolver class when cannot pluralize model name and provided overriding plural: StaffCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateStaffArgs } from \\"./args/AggregateStaffArgs\\";
import { CreateManyStaffArgs } from \\"./args/CreateManyStaffArgs\\";
import { CreateOneStaffArgs } from \\"./args/CreateOneStaffArgs\\";
import { DeleteManyStaffArgs } from \\"./args/DeleteManyStaffArgs\\";
import { DeleteOneStaffArgs } from \\"./args/DeleteOneStaffArgs\\";
import { FindFirstStaffArgs } from \\"./args/FindFirstStaffArgs\\";
import { FindFirstStaffOrThrowArgs } from \\"./args/FindFirstStaffOrThrowArgs\\";
import { FindManyStaffArgs } from \\"./args/FindManyStaffArgs\\";
import { FindUniqueStaffArgs } from \\"./args/FindUniqueStaffArgs\\";
import { FindUniqueStaffOrThrowArgs } from \\"./args/FindUniqueStaffOrThrowArgs\\";
import { GroupByStaffArgs } from \\"./args/GroupByStaffArgs\\";
import { UpdateManyStaffArgs } from \\"./args/UpdateManyStaffArgs\\";
import { UpdateOneStaffArgs } from \\"./args/UpdateOneStaffArgs\\";
import { UpsertOneStaffArgs } from \\"./args/UpsertOneStaffArgs\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";
import { Staff } from \\"../../../models/Staff\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateStaff } from \\"../../outputs/AggregateStaff\\";
import { StaffGroupBy } from \\"../../outputs/StaffGroupBy\\";

@TypeGraphQL.Resolver(_of => Staff)
export class StaffCrudResolver {
  @TypeGraphQL.Query(_returns => AggregateStaff, {
    nullable: false
  })
  async aggregateStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateStaffArgs): Promise<AggregateStaff> {
    return getPrismaFromContext(ctx).staff.aggregate({
      ...args,
      ...transformInfoIntoPrismaArgs(info),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyStaffArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: false
  })
  async createOneStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateOneStaffArgs): Promise<Staff> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyStaffArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: true
  })
  async deleteOneStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteOneStaffArgs): Promise<Staff | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => Staff, {
    nullable: true
  })
  async findFirstStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstStaffArgs): Promise<Staff | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => Staff, {
    nullable: true
  })
  async findFirstStaffOrThrow(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstStaffOrThrowArgs): Promise<Staff | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.findFirstOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [Staff], {
    nullable: false
  })
  async staffMembers(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyStaffArgs): Promise<Staff[]> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => Staff, {
    nullable: true
  })
  async staff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueStaffArgs): Promise<Staff | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => Staff, {
    nullable: true
  })
  async getStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueStaffOrThrowArgs): Promise<Staff | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.findUniqueOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [StaffGroupBy], {
    nullable: false
  })
  async groupByStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByStaffArgs): Promise<StaffGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyStaffArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: true
  })
  async updateOneStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateOneStaffArgs): Promise<Staff | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: false
  })
  async upsertOneStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertOneStaffArgs): Promise<Staff> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate resolver class when cannot pluralize model name: StaffCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateStaffArgs } from \\"./args/AggregateStaffArgs\\";
import { CreateManyStaffArgs } from \\"./args/CreateManyStaffArgs\\";
import { CreateOneStaffArgs } from \\"./args/CreateOneStaffArgs\\";
import { DeleteManyStaffArgs } from \\"./args/DeleteManyStaffArgs\\";
import { DeleteOneStaffArgs } from \\"./args/DeleteOneStaffArgs\\";
import { FindFirstStaffArgs } from \\"./args/FindFirstStaffArgs\\";
import { FindFirstStaffOrThrowArgs } from \\"./args/FindFirstStaffOrThrowArgs\\";
import { FindManyStaffArgs } from \\"./args/FindManyStaffArgs\\";
import { FindUniqueStaffArgs } from \\"./args/FindUniqueStaffArgs\\";
import { FindUniqueStaffOrThrowArgs } from \\"./args/FindUniqueStaffOrThrowArgs\\";
import { GroupByStaffArgs } from \\"./args/GroupByStaffArgs\\";
import { UpdateManyStaffArgs } from \\"./args/UpdateManyStaffArgs\\";
import { UpdateOneStaffArgs } from \\"./args/UpdateOneStaffArgs\\";
import { UpsertOneStaffArgs } from \\"./args/UpsertOneStaffArgs\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";
import { Staff } from \\"../../../models/Staff\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateStaff } from \\"../../outputs/AggregateStaff\\";
import { StaffGroupBy } from \\"../../outputs/StaffGroupBy\\";

@TypeGraphQL.Resolver(_of => Staff)
export class StaffCrudResolver {
  @TypeGraphQL.Query(_returns => AggregateStaff, {
    nullable: false
  })
  async aggregateStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateStaffArgs): Promise<AggregateStaff> {
    return getPrismaFromContext(ctx).staff.aggregate({
      ...args,
      ...transformInfoIntoPrismaArgs(info),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyStaffArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: false
  })
  async createOneStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateOneStaffArgs): Promise<Staff> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyStaffArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: true
  })
  async deleteOneStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteOneStaffArgs): Promise<Staff | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => Staff, {
    nullable: true
  })
  async findFirstStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstStaffArgs): Promise<Staff | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => Staff, {
    nullable: true
  })
  async findFirstStaffOrThrow(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstStaffOrThrowArgs): Promise<Staff | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.findFirstOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [Staff], {
    nullable: false
  })
  async findManyStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyStaffArgs): Promise<Staff[]> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => Staff, {
    nullable: true
  })
  async findUniqueStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueStaffArgs): Promise<Staff | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => Staff, {
    nullable: true
  })
  async findUniqueStaffOrThrow(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueStaffOrThrowArgs): Promise<Staff | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.findUniqueOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [StaffGroupBy], {
    nullable: false
  })
  async groupByStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByStaffArgs): Promise<StaffGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyStaffArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: true
  })
  async updateOneStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateOneStaffArgs): Promise<Staff | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: false
  })
  async upsertOneStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertOneStaffArgs): Promise<Staff> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).staff.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate resolver class when useOriginalMapping is used: FindUniqueUserOrThrowResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindUniqueUserOrThrowArgs } from \\"./args/FindUniqueUserOrThrowArgs\\";
import { User } from \\"../../../models/User\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class FindUniqueUserOrThrowResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findUniqueUserOrThrow(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUserOrThrowArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUniqueOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate resolver class when useOriginalMapping is used: FindUniqueUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class FindUniqueUserResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findUniqueUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate resolver class when useOriginalMapping is used: UserCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUserArgs } from \\"./args/AggregateUserArgs\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { CreateOneUserArgs } from \\"./args/CreateOneUserArgs\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { DeleteOneUserArgs } from \\"./args/DeleteOneUserArgs\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { FindFirstUserOrThrowArgs } from \\"./args/FindFirstUserOrThrowArgs\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { FindUniqueUserOrThrowArgs } from \\"./args/FindUniqueUserOrThrowArgs\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { UpdateOneUserArgs } from \\"./args/UpdateOneUserArgs\\";
import { UpsertOneUserArgs } from \\"./args/UpsertOneUserArgs\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateUser } from \\"../../outputs/AggregateUser\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";

@TypeGraphQL.Resolver(_of => User)
export class UserCrudResolver {
  @TypeGraphQL.Query(_returns => AggregateUser, {
    nullable: false
  })
  async aggregateUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateUserArgs): Promise<AggregateUser> {
    return getPrismaFromContext(ctx).user.aggregate({
      ...args,
      ...transformInfoIntoPrismaArgs(info),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false
  })
  async createOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateOneUserArgs): Promise<User> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true
  })
  async deleteOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteOneUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findFirstUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findFirstUserOrThrow(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstUserOrThrowArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirstOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [User], {
    nullable: false
  })
  async findManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyUserArgs): Promise<User[]> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findUniqueUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findUniqueUserOrThrow(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUserOrThrowArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUniqueOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [UserGroupBy], {
    nullable: false
  })
  async groupByUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByUserArgs): Promise<UserGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true
  })
  async updateOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateOneUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false
  })
  async upsertOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertOneUserArgs): Promise<User> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when emitRedundantTypesInfo is set to true should properly generate type info for @Args decorator: UserCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUserArgs } from \\"./args/AggregateUserArgs\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { CreateOneUserArgs } from \\"./args/CreateOneUserArgs\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { DeleteOneUserArgs } from \\"./args/DeleteOneUserArgs\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { FindFirstUserOrThrowArgs } from \\"./args/FindFirstUserOrThrowArgs\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { FindUniqueUserOrThrowArgs } from \\"./args/FindUniqueUserOrThrowArgs\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { UpdateOneUserArgs } from \\"./args/UpdateOneUserArgs\\";
import { UpsertOneUserArgs } from \\"./args/UpsertOneUserArgs\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateUser } from \\"../../outputs/AggregateUser\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";

@TypeGraphQL.Resolver(_of => User)
export class UserCrudResolver {
  @TypeGraphQL.Query(_returns => AggregateUser, {
    nullable: false
  })
  async aggregateUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args(_type => AggregateUserArgs) args: AggregateUserArgs): Promise<AggregateUser> {
    return getPrismaFromContext(ctx).user.aggregate({
      ...args,
      ...transformInfoIntoPrismaArgs(info),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args(_type => CreateManyUserArgs) args: CreateManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false
  })
  async createOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args(_type => CreateOneUserArgs) args: CreateOneUserArgs): Promise<User> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args(_type => DeleteManyUserArgs) args: DeleteManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true
  })
  async deleteOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args(_type => DeleteOneUserArgs) args: DeleteOneUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findFirstUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args(_type => FindFirstUserArgs) args: FindFirstUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findFirstUserOrThrow(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args(_type => FindFirstUserOrThrowArgs) args: FindFirstUserOrThrowArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirstOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [User], {
    nullable: false
  })
  async users(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args(_type => FindManyUserArgs) args: FindManyUserArgs): Promise<User[]> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async user(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args(_type => FindUniqueUserArgs) args: FindUniqueUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async getUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args(_type => FindUniqueUserOrThrowArgs) args: FindUniqueUserOrThrowArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUniqueOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [UserGroupBy], {
    nullable: false
  })
  async groupByUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args(_type => GroupByUserArgs) args: GroupByUserArgs): Promise<UserGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args(_type => UpdateManyUserArgs) args: UpdateManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true
  })
  async updateOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args(_type => UpdateOneUserArgs) args: UpdateOneUserArgs): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false
  })
  async upsertOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args(_type => UpsertOneUserArgs) args: UpsertOneUserArgs): Promise<User> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when emitTranspiledCode is set to true should properly generate imports in js files for resolver classes: UserCrudResolver 1`] = `
"\\"use strict\\";
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.UserCrudResolver = void 0;
const tslib_1 = require(\\"tslib\\");
const TypeGraphQL = tslib_1.__importStar(require(\\"type-graphql\\"));
const AggregateUserArgs_1 = require(\\"./args/AggregateUserArgs\\");
const CreateManyUserArgs_1 = require(\\"./args/CreateManyUserArgs\\");
const CreateOneUserArgs_1 = require(\\"./args/CreateOneUserArgs\\");
const DeleteManyUserArgs_1 = require(\\"./args/DeleteManyUserArgs\\");
const DeleteOneUserArgs_1 = require(\\"./args/DeleteOneUserArgs\\");
const FindFirstUserArgs_1 = require(\\"./args/FindFirstUserArgs\\");
const FindFirstUserOrThrowArgs_1 = require(\\"./args/FindFirstUserOrThrowArgs\\");
const FindManyUserArgs_1 = require(\\"./args/FindManyUserArgs\\");
const FindUniqueUserArgs_1 = require(\\"./args/FindUniqueUserArgs\\");
const FindUniqueUserOrThrowArgs_1 = require(\\"./args/FindUniqueUserOrThrowArgs\\");
const GroupByUserArgs_1 = require(\\"./args/GroupByUserArgs\\");
const UpdateManyUserArgs_1 = require(\\"./args/UpdateManyUserArgs\\");
const UpdateOneUserArgs_1 = require(\\"./args/UpdateOneUserArgs\\");
const UpsertOneUserArgs_1 = require(\\"./args/UpsertOneUserArgs\\");
const helpers_1 = require(\\"../../../helpers\\");
const User_1 = require(\\"../../../models/User\\");
const AffectedRowsOutput_1 = require(\\"../../outputs/AffectedRowsOutput\\");
const AggregateUser_1 = require(\\"../../outputs/AggregateUser\\");
const UserGroupBy_1 = require(\\"../../outputs/UserGroupBy\\");
let UserCrudResolver = class UserCrudResolver {
    async aggregateUser(ctx, info, args) {
        return (0, helpers_1.getPrismaFromContext)(ctx).user.aggregate({
            ...args,
            ...(0, helpers_1.transformInfoIntoPrismaArgs)(info),
        });
    }
    async createManyUser(ctx, info, args) {
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info);
        return (0, helpers_1.getPrismaFromContext)(ctx).user.createMany({
            ...args,
            ...(_count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count)),
        });
    }
    async createOneUser(ctx, info, args) {
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info);
        return (0, helpers_1.getPrismaFromContext)(ctx).user.create({
            ...args,
            ...(_count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count)),
        });
    }
    async deleteManyUser(ctx, info, args) {
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info);
        return (0, helpers_1.getPrismaFromContext)(ctx).user.deleteMany({
            ...args,
            ...(_count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count)),
        });
    }
    async deleteOneUser(ctx, info, args) {
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info);
        return (0, helpers_1.getPrismaFromContext)(ctx).user.delete({
            ...args,
            ...(_count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count)),
        });
    }
    async findFirstUser(ctx, info, args) {
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info);
        return (0, helpers_1.getPrismaFromContext)(ctx).user.findFirst({
            ...args,
            ...(_count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count)),
        });
    }
    async findFirstUserOrThrow(ctx, info, args) {
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info);
        return (0, helpers_1.getPrismaFromContext)(ctx).user.findFirstOrThrow({
            ...args,
            ...(_count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count)),
        });
    }
    async users(ctx, info, args) {
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info);
        return (0, helpers_1.getPrismaFromContext)(ctx).user.findMany({
            ...args,
            ...(_count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count)),
        });
    }
    async user(ctx, info, args) {
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info);
        return (0, helpers_1.getPrismaFromContext)(ctx).user.findUnique({
            ...args,
            ...(_count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count)),
        });
    }
    async getUser(ctx, info, args) {
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info);
        return (0, helpers_1.getPrismaFromContext)(ctx).user.findUniqueOrThrow({
            ...args,
            ...(_count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count)),
        });
    }
    async groupByUser(ctx, info, args) {
        const { _count, _avg, _sum, _min, _max } = (0, helpers_1.transformInfoIntoPrismaArgs)(info);
        return (0, helpers_1.getPrismaFromContext)(ctx).user.groupBy({
            ...args,
            ...Object.fromEntries(Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)),
        });
    }
    async updateManyUser(ctx, info, args) {
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info);
        return (0, helpers_1.getPrismaFromContext)(ctx).user.updateMany({
            ...args,
            ...(_count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count)),
        });
    }
    async updateOneUser(ctx, info, args) {
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info);
        return (0, helpers_1.getPrismaFromContext)(ctx).user.update({
            ...args,
            ...(_count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count)),
        });
    }
    async upsertOneUser(ctx, info, args) {
        const { _count } = (0, helpers_1.transformInfoIntoPrismaArgs)(info);
        return (0, helpers_1.getPrismaFromContext)(ctx).user.upsert({
            ...args,
            ...(_count && (0, helpers_1.transformCountFieldIntoSelectRelationsCount)(_count)),
        });
    }
};
exports.UserCrudResolver = UserCrudResolver;
tslib_1.__decorate([
    TypeGraphQL.Query(_returns => AggregateUser_1.AggregateUser, {
        nullable: false
    }),
    tslib_1.__param(0, TypeGraphQL.Ctx()),
    tslib_1.__param(1, TypeGraphQL.Info()),
    tslib_1.__param(2, TypeGraphQL.Args()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, AggregateUserArgs_1.AggregateUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"aggregateUser\\", null);
tslib_1.__decorate([
    TypeGraphQL.Mutation(_returns => AffectedRowsOutput_1.AffectedRowsOutput, {
        nullable: false
    }),
    tslib_1.__param(0, TypeGraphQL.Ctx()),
    tslib_1.__param(1, TypeGraphQL.Info()),
    tslib_1.__param(2, TypeGraphQL.Args()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, CreateManyUserArgs_1.CreateManyUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"createManyUser\\", null);
tslib_1.__decorate([
    TypeGraphQL.Mutation(_returns => User_1.User, {
        nullable: false
    }),
    tslib_1.__param(0, TypeGraphQL.Ctx()),
    tslib_1.__param(1, TypeGraphQL.Info()),
    tslib_1.__param(2, TypeGraphQL.Args()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, CreateOneUserArgs_1.CreateOneUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"createOneUser\\", null);
tslib_1.__decorate([
    TypeGraphQL.Mutation(_returns => AffectedRowsOutput_1.AffectedRowsOutput, {
        nullable: false
    }),
    tslib_1.__param(0, TypeGraphQL.Ctx()),
    tslib_1.__param(1, TypeGraphQL.Info()),
    tslib_1.__param(2, TypeGraphQL.Args()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, DeleteManyUserArgs_1.DeleteManyUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"deleteManyUser\\", null);
tslib_1.__decorate([
    TypeGraphQL.Mutation(_returns => User_1.User, {
        nullable: true
    }),
    tslib_1.__param(0, TypeGraphQL.Ctx()),
    tslib_1.__param(1, TypeGraphQL.Info()),
    tslib_1.__param(2, TypeGraphQL.Args()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, DeleteOneUserArgs_1.DeleteOneUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"deleteOneUser\\", null);
tslib_1.__decorate([
    TypeGraphQL.Query(_returns => User_1.User, {
        nullable: true
    }),
    tslib_1.__param(0, TypeGraphQL.Ctx()),
    tslib_1.__param(1, TypeGraphQL.Info()),
    tslib_1.__param(2, TypeGraphQL.Args()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, FindFirstUserArgs_1.FindFirstUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"findFirstUser\\", null);
tslib_1.__decorate([
    TypeGraphQL.Query(_returns => User_1.User, {
        nullable: true
    }),
    tslib_1.__param(0, TypeGraphQL.Ctx()),
    tslib_1.__param(1, TypeGraphQL.Info()),
    tslib_1.__param(2, TypeGraphQL.Args()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, FindFirstUserOrThrowArgs_1.FindFirstUserOrThrowArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"findFirstUserOrThrow\\", null);
tslib_1.__decorate([
    TypeGraphQL.Query(_returns => [User_1.User], {
        nullable: false
    }),
    tslib_1.__param(0, TypeGraphQL.Ctx()),
    tslib_1.__param(1, TypeGraphQL.Info()),
    tslib_1.__param(2, TypeGraphQL.Args()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, FindManyUserArgs_1.FindManyUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"users\\", null);
tslib_1.__decorate([
    TypeGraphQL.Query(_returns => User_1.User, {
        nullable: true
    }),
    tslib_1.__param(0, TypeGraphQL.Ctx()),
    tslib_1.__param(1, TypeGraphQL.Info()),
    tslib_1.__param(2, TypeGraphQL.Args()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, FindUniqueUserArgs_1.FindUniqueUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"user\\", null);
tslib_1.__decorate([
    TypeGraphQL.Query(_returns => User_1.User, {
        nullable: true
    }),
    tslib_1.__param(0, TypeGraphQL.Ctx()),
    tslib_1.__param(1, TypeGraphQL.Info()),
    tslib_1.__param(2, TypeGraphQL.Args()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, FindUniqueUserOrThrowArgs_1.FindUniqueUserOrThrowArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"getUser\\", null);
tslib_1.__decorate([
    TypeGraphQL.Query(_returns => [UserGroupBy_1.UserGroupBy], {
        nullable: false
    }),
    tslib_1.__param(0, TypeGraphQL.Ctx()),
    tslib_1.__param(1, TypeGraphQL.Info()),
    tslib_1.__param(2, TypeGraphQL.Args()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, GroupByUserArgs_1.GroupByUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"groupByUser\\", null);
tslib_1.__decorate([
    TypeGraphQL.Mutation(_returns => AffectedRowsOutput_1.AffectedRowsOutput, {
        nullable: false
    }),
    tslib_1.__param(0, TypeGraphQL.Ctx()),
    tslib_1.__param(1, TypeGraphQL.Info()),
    tslib_1.__param(2, TypeGraphQL.Args()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, UpdateManyUserArgs_1.UpdateManyUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"updateManyUser\\", null);
tslib_1.__decorate([
    TypeGraphQL.Mutation(_returns => User_1.User, {
        nullable: true
    }),
    tslib_1.__param(0, TypeGraphQL.Ctx()),
    tslib_1.__param(1, TypeGraphQL.Info()),
    tslib_1.__param(2, TypeGraphQL.Args()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, UpdateOneUserArgs_1.UpdateOneUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"updateOneUser\\", null);
tslib_1.__decorate([
    TypeGraphQL.Mutation(_returns => User_1.User, {
        nullable: false
    }),
    tslib_1.__param(0, TypeGraphQL.Ctx()),
    tslib_1.__param(1, TypeGraphQL.Info()),
    tslib_1.__param(2, TypeGraphQL.Args()),
    tslib_1.__metadata(\\"design:type\\", Function),
    tslib_1.__metadata(\\"design:paramtypes\\", [Object, Object, UpsertOneUserArgs_1.UpsertOneUserArgs]),
    tslib_1.__metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"upsertOneUser\\", null);
exports.UserCrudResolver = UserCrudResolver = tslib_1.__decorate([
    TypeGraphQL.Resolver(_of => User_1.User)
], UserCrudResolver);
"
`;

exports[`crud when formatGeneratedCode is set to 'prettier' should properly format generated files for resolver classes: UserCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUserArgs } from \\"./args/AggregateUserArgs\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { CreateOneUserArgs } from \\"./args/CreateOneUserArgs\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { DeleteOneUserArgs } from \\"./args/DeleteOneUserArgs\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { FindFirstUserOrThrowArgs } from \\"./args/FindFirstUserOrThrowArgs\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { FindUniqueUserOrThrowArgs } from \\"./args/FindUniqueUserOrThrowArgs\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { UpdateOneUserArgs } from \\"./args/UpdateOneUserArgs\\";
import { UpsertOneUserArgs } from \\"./args/UpsertOneUserArgs\\";
import {
  transformInfoIntoPrismaArgs,
  getPrismaFromContext,
  transformCountFieldIntoSelectRelationsCount,
} from \\"../../../helpers\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateUser } from \\"../../outputs/AggregateUser\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";

@TypeGraphQL.Resolver(_of => User)
export class UserCrudResolver {
  @TypeGraphQL.Query(_returns => AggregateUser, {
    nullable: false,
  })
  async aggregateUser(
    @TypeGraphQL.Ctx() ctx: any,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: AggregateUserArgs,
  ): Promise<AggregateUser> {
    return getPrismaFromContext(ctx).user.aggregate({
      ...args,
      ...transformInfoIntoPrismaArgs(info),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false,
  })
  async createManyUser(
    @TypeGraphQL.Ctx() ctx: any,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: CreateManyUserArgs,
  ): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false,
  })
  async createOneUser(
    @TypeGraphQL.Ctx() ctx: any,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: CreateOneUserArgs,
  ): Promise<User> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false,
  })
  async deleteManyUser(
    @TypeGraphQL.Ctx() ctx: any,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: DeleteManyUserArgs,
  ): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true,
  })
  async deleteOneUser(
    @TypeGraphQL.Ctx() ctx: any,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: DeleteOneUserArgs,
  ): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true,
  })
  async findFirstUser(
    @TypeGraphQL.Ctx() ctx: any,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: FindFirstUserArgs,
  ): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true,
  })
  async findFirstUserOrThrow(
    @TypeGraphQL.Ctx() ctx: any,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: FindFirstUserOrThrowArgs,
  ): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirstOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [User], {
    nullable: false,
  })
  async users(
    @TypeGraphQL.Ctx() ctx: any,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: FindManyUserArgs,
  ): Promise<User[]> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true,
  })
  async user(
    @TypeGraphQL.Ctx() ctx: any,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: FindUniqueUserArgs,
  ): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true,
  })
  async getUser(
    @TypeGraphQL.Ctx() ctx: any,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: FindUniqueUserOrThrowArgs,
  ): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUniqueOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [UserGroupBy], {
    nullable: false,
  })
  async groupByUser(
    @TypeGraphQL.Ctx() ctx: any,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: GroupByUserArgs,
  ): Promise<UserGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } =
      transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(
          ([_, v]) => v != null,
        ),
      ),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false,
  })
  async updateManyUser(
    @TypeGraphQL.Ctx() ctx: any,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: UpdateManyUserArgs,
  ): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true,
  })
  async updateOneUser(
    @TypeGraphQL.Ctx() ctx: any,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: UpdateOneUserArgs,
  ): Promise<User | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false,
  })
  async upsertOneUser(
    @TypeGraphQL.Ctx() ctx: any,
    @TypeGraphQL.Info() info: GraphQLResolveInfo,
    @TypeGraphQL.Args() args: UpsertOneUserArgs,
  ): Promise<User> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when formatGeneratedCode is set to false should not format generated files for resolver classes: UserCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUserArgs } from \\"./args/AggregateUserArgs\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { CreateOneUserArgs } from \\"./args/CreateOneUserArgs\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { DeleteOneUserArgs } from \\"./args/DeleteOneUserArgs\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { FindFirstUserOrThrowArgs } from \\"./args/FindFirstUserOrThrowArgs\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { FindUniqueUserOrThrowArgs } from \\"./args/FindUniqueUserOrThrowArgs\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { UpdateOneUserArgs } from \\"./args/UpdateOneUserArgs\\";
import { UpsertOneUserArgs } from \\"./args/UpsertOneUserArgs\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateUser } from \\"../../outputs/AggregateUser\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";

@TypeGraphQL.Resolver(_of => User)
export class UserCrudResolver {
    @TypeGraphQL.Query(_returns => AggregateUser, {
            nullable: false
        })
    async aggregateUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateUserArgs): Promise<AggregateUser> {
         return getPrismaFromContext(ctx).user.aggregate({
                      ...args,
                      ...transformInfoIntoPrismaArgs(info),
                    });
    }

    @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
            nullable: false
        })
    async createManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyUserArgs): Promise<AffectedRowsOutput> {
         const { _count } = transformInfoIntoPrismaArgs(info);
                    return getPrismaFromContext(ctx).user.createMany({
                      ...args,
                      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
                    });
    }

    @TypeGraphQL.Mutation(_returns => User, {
            nullable: false
        })
    async createOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateOneUserArgs): Promise<User> {
         const { _count } = transformInfoIntoPrismaArgs(info);
                    return getPrismaFromContext(ctx).user.create({
                      ...args,
                      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
                    });
    }

    @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
            nullable: false
        })
    async deleteManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyUserArgs): Promise<AffectedRowsOutput> {
         const { _count } = transformInfoIntoPrismaArgs(info);
                    return getPrismaFromContext(ctx).user.deleteMany({
                      ...args,
                      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
                    });
    }

    @TypeGraphQL.Mutation(_returns => User, {
            nullable: true
        })
    async deleteOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteOneUserArgs): Promise<User | null> {
         const { _count } = transformInfoIntoPrismaArgs(info);
                    return getPrismaFromContext(ctx).user.delete({
                      ...args,
                      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
                    });
    }

    @TypeGraphQL.Query(_returns => User, {
            nullable: true
        })
    async findFirstUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstUserArgs): Promise<User | null> {
         const { _count } = transformInfoIntoPrismaArgs(info);
                    return getPrismaFromContext(ctx).user.findFirst({
                      ...args,
                      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
                    });
    }

    @TypeGraphQL.Query(_returns => User, {
            nullable: true
        })
    async findFirstUserOrThrow(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstUserOrThrowArgs): Promise<User | null> {
         const { _count } = transformInfoIntoPrismaArgs(info);
                    return getPrismaFromContext(ctx).user.findFirstOrThrow({
                      ...args,
                      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
                    });
    }

    @TypeGraphQL.Query(_returns => [User], {
            nullable: false
        })
    async users(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyUserArgs): Promise<User[]> {
         const { _count } = transformInfoIntoPrismaArgs(info);
                    return getPrismaFromContext(ctx).user.findMany({
                      ...args,
                      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
                    });
    }

    @TypeGraphQL.Query(_returns => User, {
            nullable: true
        })
    async user(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUserArgs): Promise<User | null> {
         const { _count } = transformInfoIntoPrismaArgs(info);
                    return getPrismaFromContext(ctx).user.findUnique({
                      ...args,
                      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
                    });
    }

    @TypeGraphQL.Query(_returns => User, {
            nullable: true
        })
    async getUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUserOrThrowArgs): Promise<User | null> {
         const { _count } = transformInfoIntoPrismaArgs(info);
                    return getPrismaFromContext(ctx).user.findUniqueOrThrow({
                      ...args,
                      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
                    });
    }

    @TypeGraphQL.Query(_returns => [UserGroupBy], {
            nullable: false
        })
    async groupByUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByUserArgs): Promise<UserGroupBy[]> {
         const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info);
         return getPrismaFromContext(ctx).user.groupBy({
                      ...args,
                      ...Object.fromEntries(
                        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
                      ),
                    });
    }

    @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
            nullable: false
        })
    async updateManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyUserArgs): Promise<AffectedRowsOutput> {
         const { _count } = transformInfoIntoPrismaArgs(info);
                    return getPrismaFromContext(ctx).user.updateMany({
                      ...args,
                      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
                    });
    }

    @TypeGraphQL.Mutation(_returns => User, {
            nullable: true
        })
    async updateOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateOneUserArgs): Promise<User | null> {
         const { _count } = transformInfoIntoPrismaArgs(info);
                    return getPrismaFromContext(ctx).user.update({
                      ...args,
                      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
                    });
    }

    @TypeGraphQL.Mutation(_returns => User, {
            nullable: false
        })
    async upsertOneUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertOneUserArgs): Promise<User> {
         const { _count } = transformInfoIntoPrismaArgs(info);
                    return getPrismaFromContext(ctx).user.upsert({
                      ...args,
                      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
                    });
    }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: AggregateClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateClientArgs } from \\"./args/AggregateClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { AggregateClient } from \\"../../outputs/AggregateClient\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class AggregateClientResolver {
  @TypeGraphQL.Query(_returns => AggregateClient, {
    nullable: false
  })
  async aggregateClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateClientArgs): Promise<AggregateClient> {
    return getPrismaFromContext(ctx).user.aggregate({
      ...args,
      ...transformInfoIntoPrismaArgs(info),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: CreateManyClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { CreateManyClientArgs } from \\"./args/CreateManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class CreateManyClientResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyClientArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: CreateOneClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { CreateOneClientArgs } from \\"./args/CreateOneClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class CreateOneClientResolver {
  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: false
  })
  async createOneClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateOneClientArgs): Promise<Client> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: DeleteManyClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { DeleteManyClientArgs } from \\"./args/DeleteManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class DeleteManyClientResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyClientArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: DeleteOneClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { DeleteOneClientArgs } from \\"./args/DeleteOneClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class DeleteOneClientResolver {
  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: true
  })
  async deleteOneClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteOneClientArgs): Promise<Client | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: FindFirstClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindFirstClientArgs } from \\"./args/FindFirstClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class FindFirstClientResolver {
  @TypeGraphQL.Query(_returns => Client, {
    nullable: true
  })
  async findFirstClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstClientArgs): Promise<Client | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: FindManyClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindManyClientArgs } from \\"./args/FindManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class FindManyClientResolver {
  @TypeGraphQL.Query(_returns => [Client], {
    nullable: false
  })
  async clients(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyClientArgs): Promise<Client[]> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: FindUniqueClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { FindUniqueClientArgs } from \\"./args/FindUniqueClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class FindUniqueClientResolver {
  @TypeGraphQL.Query(_returns => Client, {
    nullable: true
  })
  async client(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueClientArgs): Promise<Client | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: GroupByClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { GroupByClientArgs } from \\"./args/GroupByClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { ClientGroupBy } from \\"../../outputs/ClientGroupBy\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class GroupByClientResolver {
  @TypeGraphQL.Query(_returns => [ClientGroupBy], {
    nullable: false
  })
  async groupByClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByClientArgs): Promise<ClientGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: UpdateManyClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { UpdateManyClientArgs } from \\"./args/UpdateManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class UpdateManyClientResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyClientArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: UpdateOneClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { UpdateOneClientArgs } from \\"./args/UpdateOneClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class UpdateOneClientResolver {
  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: true
  })
  async updateOneClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateOneClientArgs): Promise<Client | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: UpsertOneClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { UpsertOneClientArgs } from \\"./args/UpsertOneClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class UpsertOneClientResolver {
  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: false
  })
  async upsertOneClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertOneClientArgs): Promise<Client> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: AggregateClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientOrderByWithRelationInput } from \\"../../../inputs/ClientOrderByWithRelationInput\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class AggregateClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;

  @TypeGraphQL.Field(_type => [ClientOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: ClientOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, {
    nullable: true
  })
  cursor?: ClientWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: CreateClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientCreateInput } from \\"../../../inputs/ClientCreateInput\\";

@TypeGraphQL.ArgsType()
export class CreateOneClientArgs {
  @TypeGraphQL.Field(_type => ClientCreateInput, {
    nullable: false
  })
  data!: ClientCreateInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: CreateManyClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientCreateManyInput } from \\"../../../inputs/ClientCreateManyInput\\";

@TypeGraphQL.ArgsType()
export class CreateManyClientArgs {
  @TypeGraphQL.Field(_type => [ClientCreateManyInput], {
    nullable: false
  })
  data!: ClientCreateManyInput[];

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  skipDuplicates?: boolean | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: DeleteClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class DeleteOneClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, {
    nullable: false
  })
  where!: ClientWhereUniqueInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: DeleteManyClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";

@TypeGraphQL.ArgsType()
export class DeleteManyClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: FindFirstClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientOrderByWithRelationInput } from \\"../../../inputs/ClientOrderByWithRelationInput\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";
import { ClientScalarFieldEnum } from \\"../../../../enums/ClientScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindFirstClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;

  @TypeGraphQL.Field(_type => [ClientOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: ClientOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, {
    nullable: true
  })
  cursor?: ClientWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [ClientScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: FindManyClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientOrderByWithRelationInput } from \\"../../../inputs/ClientOrderByWithRelationInput\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";
import { ClientScalarFieldEnum } from \\"../../../../enums/ClientScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindManyClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;

  @TypeGraphQL.Field(_type => [ClientOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: ClientOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, {
    nullable: true
  })
  cursor?: ClientWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [ClientScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: FindUniqueClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class FindUniqueClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, {
    nullable: false
  })
  where!: ClientWhereUniqueInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: GroupByClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientOrderByWithAggregationInput } from \\"../../../inputs/ClientOrderByWithAggregationInput\\";
import { ClientScalarWhereWithAggregatesInput } from \\"../../../inputs/ClientScalarWhereWithAggregatesInput\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";
import { ClientScalarFieldEnum } from \\"../../../../enums/ClientScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class GroupByClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;

  @TypeGraphQL.Field(_type => [ClientOrderByWithAggregationInput], {
    nullable: true
  })
  orderBy?: ClientOrderByWithAggregationInput[] | undefined;

  @TypeGraphQL.Field(_type => [ClientScalarFieldEnum], {
    nullable: false
  })
  by!: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\">;

  @TypeGraphQL.Field(_type => ClientScalarWhereWithAggregatesInput, {
    nullable: true
  })
  having?: ClientScalarWhereWithAggregatesInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: Index 1`] = `
"export { AggregateClientArgs } from \\"./AggregateClientArgs\\";
export { CreateManyClientArgs } from \\"./CreateManyClientArgs\\";
export { CreateOneClientArgs } from \\"./CreateOneClientArgs\\";
export { DeleteManyClientArgs } from \\"./DeleteManyClientArgs\\";
export { DeleteOneClientArgs } from \\"./DeleteOneClientArgs\\";
export { FindFirstClientArgs } from \\"./FindFirstClientArgs\\";
export { FindFirstClientOrThrowArgs } from \\"./FindFirstClientOrThrowArgs\\";
export { FindManyClientArgs } from \\"./FindManyClientArgs\\";
export { FindUniqueClientArgs } from \\"./FindUniqueClientArgs\\";
export { FindUniqueClientOrThrowArgs } from \\"./FindUniqueClientOrThrowArgs\\";
export { GroupByClientArgs } from \\"./GroupByClientArgs\\";
export { UpdateManyClientArgs } from \\"./UpdateManyClientArgs\\";
export { UpdateOneClientArgs } from \\"./UpdateOneClientArgs\\";
export { UpsertOneClientArgs } from \\"./UpsertOneClientArgs\\";
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: UpdateClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientUpdateInput } from \\"../../../inputs/ClientUpdateInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpdateOneClientArgs {
  @TypeGraphQL.Field(_type => ClientUpdateInput, {
    nullable: false
  })
  data!: ClientUpdateInput;

  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, {
    nullable: false
  })
  where!: ClientWhereUniqueInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: UpdateManyClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientUpdateManyMutationInput } from \\"../../../inputs/ClientUpdateManyMutationInput\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";

@TypeGraphQL.ArgsType()
export class UpdateManyClientArgs {
  @TypeGraphQL.Field(_type => ClientUpdateManyMutationInput, {
    nullable: false
  })
  data!: ClientUpdateManyMutationInput;

  @TypeGraphQL.Field(_type => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: UpsertClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientCreateInput } from \\"../../../inputs/ClientCreateInput\\";
import { ClientUpdateInput } from \\"../../../inputs/ClientUpdateInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpsertOneClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, {
    nullable: false
  })
  where!: ClientWhereUniqueInput;

  @TypeGraphQL.Field(_type => ClientCreateInput, {
    nullable: false
  })
  create!: ClientCreateInput;

  @TypeGraphQL.Field(_type => ClientUpdateInput, {
    nullable: false
  })
  update!: ClientUpdateInput;
}
"
`;

exports[`crud when model is renamed should properly generate resolver class for single prisma model: AggregateMainUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateMainUserArgs } from \\"./args/AggregateMainUserArgs\\";
import { MainUser } from \\"../../../models/MainUser\\";
import { AggregateMainUser } from \\"../../outputs/AggregateMainUser\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => MainUser)
export class AggregateMainUserResolver {
  @TypeGraphQL.Query(_returns => AggregateMainUser, {
    nullable: false
  })
  async aggregateMainUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateMainUserArgs): Promise<AggregateMainUser> {
    return getPrismaFromContext(ctx).user.aggregate({
      ...args,
      ...transformInfoIntoPrismaArgs(info),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate resolver class for single prisma model: ClientCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateClientArgs } from \\"./args/AggregateClientArgs\\";
import { CreateManyClientArgs } from \\"./args/CreateManyClientArgs\\";
import { CreateOneClientArgs } from \\"./args/CreateOneClientArgs\\";
import { DeleteManyClientArgs } from \\"./args/DeleteManyClientArgs\\";
import { DeleteOneClientArgs } from \\"./args/DeleteOneClientArgs\\";
import { FindFirstClientArgs } from \\"./args/FindFirstClientArgs\\";
import { FindFirstClientOrThrowArgs } from \\"./args/FindFirstClientOrThrowArgs\\";
import { FindManyClientArgs } from \\"./args/FindManyClientArgs\\";
import { FindUniqueClientArgs } from \\"./args/FindUniqueClientArgs\\";
import { FindUniqueClientOrThrowArgs } from \\"./args/FindUniqueClientOrThrowArgs\\";
import { GroupByClientArgs } from \\"./args/GroupByClientArgs\\";
import { UpdateManyClientArgs } from \\"./args/UpdateManyClientArgs\\";
import { UpdateOneClientArgs } from \\"./args/UpdateOneClientArgs\\";
import { UpsertOneClientArgs } from \\"./args/UpsertOneClientArgs\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";
import { Client } from \\"../../../models/Client\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateClient } from \\"../../outputs/AggregateClient\\";
import { ClientGroupBy } from \\"../../outputs/ClientGroupBy\\";

@TypeGraphQL.Resolver(_of => Client)
export class ClientCrudResolver {
  @TypeGraphQL.Query(_returns => AggregateClient, {
    nullable: false
  })
  async aggregateClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateClientArgs): Promise<AggregateClient> {
    return getPrismaFromContext(ctx).user.aggregate({
      ...args,
      ...transformInfoIntoPrismaArgs(info),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyClientArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: false
  })
  async createOneClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateOneClientArgs): Promise<Client> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyClientArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: true
  })
  async deleteOneClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteOneClientArgs): Promise<Client | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => Client, {
    nullable: true
  })
  async findFirstClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstClientArgs): Promise<Client | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => Client, {
    nullable: true
  })
  async findFirstClientOrThrow(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstClientOrThrowArgs): Promise<Client | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirstOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [Client], {
    nullable: false
  })
  async findManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyClientArgs): Promise<Client[]> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => Client, {
    nullable: true
  })
  async findUniqueClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueClientArgs): Promise<Client | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => Client, {
    nullable: true
  })
  async findUniqueClientOrThrow(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueClientOrThrowArgs): Promise<Client | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUniqueOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [ClientGroupBy], {
    nullable: false
  })
  async groupByClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByClientArgs): Promise<ClientGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyClientArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: true
  })
  async updateOneClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateOneClientArgs): Promise<Client | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: false
  })
  async upsertOneClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertOneClientArgs): Promise<Client> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate resolver class for single prisma model: GroupByMainUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { GroupByMainUserArgs } from \\"./args/GroupByMainUserArgs\\";
import { MainUser } from \\"../../../models/MainUser\\";
import { MainUserGroupBy } from \\"../../outputs/MainUserGroupBy\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => MainUser)
export class GroupByMainUserResolver {
  @TypeGraphQL.Query(_returns => [MainUserGroupBy], {
    nullable: false
  })
  async groupByMainUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByMainUserArgs): Promise<MainUserGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate resolver class for single prisma model: MainUserCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import type { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateMainUserArgs } from \\"./args/AggregateMainUserArgs\\";
import { CreateManyMainUserArgs } from \\"./args/CreateManyMainUserArgs\\";
import { CreateOneMainUserArgs } from \\"./args/CreateOneMainUserArgs\\";
import { DeleteManyMainUserArgs } from \\"./args/DeleteManyMainUserArgs\\";
import { DeleteOneMainUserArgs } from \\"./args/DeleteOneMainUserArgs\\";
import { FindFirstMainUserArgs } from \\"./args/FindFirstMainUserArgs\\";
import { FindFirstMainUserOrThrowArgs } from \\"./args/FindFirstMainUserOrThrowArgs\\";
import { FindManyMainUserArgs } from \\"./args/FindManyMainUserArgs\\";
import { FindUniqueMainUserArgs } from \\"./args/FindUniqueMainUserArgs\\";
import { FindUniqueMainUserOrThrowArgs } from \\"./args/FindUniqueMainUserOrThrowArgs\\";
import { GroupByMainUserArgs } from \\"./args/GroupByMainUserArgs\\";
import { UpdateManyMainUserArgs } from \\"./args/UpdateManyMainUserArgs\\";
import { UpdateOneMainUserArgs } from \\"./args/UpdateOneMainUserArgs\\";
import { UpsertOneMainUserArgs } from \\"./args/UpsertOneMainUserArgs\\";
import { transformInfoIntoPrismaArgs, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";
import { MainUser } from \\"../../../models/MainUser\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateMainUser } from \\"../../outputs/AggregateMainUser\\";
import { MainUserGroupBy } from \\"../../outputs/MainUserGroupBy\\";

@TypeGraphQL.Resolver(_of => MainUser)
export class MainUserCrudResolver {
  @TypeGraphQL.Query(_returns => AggregateMainUser, {
    nullable: false
  })
  async aggregateMainUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateMainUserArgs): Promise<AggregateMainUser> {
    return getPrismaFromContext(ctx).user.aggregate({
      ...args,
      ...transformInfoIntoPrismaArgs(info),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyMainUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyMainUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => MainUser, {
    nullable: false
  })
  async createOneMainUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateOneMainUserArgs): Promise<MainUser> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyMainUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyMainUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => MainUser, {
    nullable: true
  })
  async deleteOneMainUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteOneMainUserArgs): Promise<MainUser | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => MainUser, {
    nullable: true
  })
  async findFirstMainUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstMainUserArgs): Promise<MainUser | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => MainUser, {
    nullable: true
  })
  async findFirstMainUserOrThrow(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstMainUserOrThrowArgs): Promise<MainUser | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findFirstOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [MainUser], {
    nullable: false
  })
  async mainUsers(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyMainUserArgs): Promise<MainUser[]> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => MainUser, {
    nullable: true
  })
  async mainUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueMainUserArgs): Promise<MainUser | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => MainUser, {
    nullable: true
  })
  async getMainUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueMainUserOrThrowArgs): Promise<MainUser | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.findUniqueOrThrow({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [MainUserGroupBy], {
    nullable: false
  })
  async groupByMainUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByMainUserArgs): Promise<MainUserGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyMainUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyMainUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => MainUser, {
    nullable: true
  })
  async updateOneMainUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateOneMainUserArgs): Promise<MainUser | null> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => MainUser, {
    nullable: false
  })
  async upsertOneMainUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertOneMainUserArgs): Promise<MainUser> {
    const { _count } = transformInfoIntoPrismaArgs(info);
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when useUncheckedScalarInputs mode is enabled should properly generate create and update args classes: CreateOneUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUncheckedCreateInput } from \\"../../../inputs/UserUncheckedCreateInput\\";

@TypeGraphQL.ArgsType()
export class CreateOneUserArgs {
  @TypeGraphQL.Field(_type => UserUncheckedCreateInput, {
    nullable: false
  })
  data!: UserUncheckedCreateInput;
}
"
`;

exports[`crud when useUncheckedScalarInputs mode is enabled should properly generate create and update args classes: UpdateManyUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUncheckedUpdateManyInput } from \\"../../../inputs/UserUncheckedUpdateManyInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";

@TypeGraphQL.ArgsType()
export class UpdateManyUserArgs {
  @TypeGraphQL.Field(_type => UserUncheckedUpdateManyInput, {
    nullable: false
  })
  data!: UserUncheckedUpdateManyInput;

  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;
}
"
`;

exports[`crud when useUncheckedScalarInputs mode is enabled should properly generate create and update args classes: UpdateOneUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUncheckedUpdateInput } from \\"../../../inputs/UserUncheckedUpdateInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpdateOneUserArgs {
  @TypeGraphQL.Field(_type => UserUncheckedUpdateInput, {
    nullable: false
  })
  data!: UserUncheckedUpdateInput;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud when useUncheckedScalarInputs mode is enabled should properly generate create and update args classes: UpsertOneUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUncheckedCreateInput } from \\"../../../inputs/UserUncheckedCreateInput\\";
import { UserUncheckedUpdateInput } from \\"../../../inputs/UserUncheckedUpdateInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpsertOneUserArgs {
  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;

  @TypeGraphQL.Field(_type => UserUncheckedCreateInput, {
    nullable: false
  })
  create!: UserUncheckedCreateInput;

  @TypeGraphQL.Field(_type => UserUncheckedUpdateInput, {
    nullable: false
  })
  update!: UserUncheckedUpdateInput;
}
"
`;
