// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`crud should properly generate actions resolver classes for prisma model: CreateManyUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class CreateManyUserResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: CreateOneUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { CreateUserArgs } from \\"./args/CreateUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class CreateUserResolver {
  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false
  })
  async createUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateUserArgs): Promise<User> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: DeleteManyUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class DeleteManyUserResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: DeleteUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { DeleteUserArgs } from \\"./args/DeleteUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class DeleteUserResolver {
  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true
  })
  async deleteUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteUserArgs): Promise<User | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindFirstUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class FindFirstUserResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findFirstUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstUserArgs): Promise<User | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindManyUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class FindManyUserResolver {
  @TypeGraphQL.Query(_returns => [User], {
    nullable: false
  })
  async users(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyUserArgs): Promise<User[]> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindUniqueUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class FindUniqueUserResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async user(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUserArgs): Promise<User | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: GroupByUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { User } from \\"../../../models/User\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class GroupByUserResolver {
  @TypeGraphQL.Query(_returns => [UserGroupBy], {
    nullable: false
  })
  async groupByUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByUserArgs): Promise<UserGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: Index 1`] = `
"export * from \\"./resolvers-actions.index\\";
export * from \\"./resolvers-crud.index\\";
export * from \\"./args.index\\";
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: UpdateManyUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class UpdateManyUserResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: UpdateUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { UpdateUserArgs } from \\"./args/UpdateUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class UpdateUserResolver {
  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true
  })
  async updateUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateUserArgs): Promise<User | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: UpsertUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { UpsertUserArgs } from \\"./args/UpsertUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class UpsertUserResolver {
  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false
  })
  async upsertUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertUserArgs): Promise<User> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: actionsIndex 1`] = `
"export { FindUniqueUserResolver } from \\"./User/FindUniqueUserResolver\\";
export { FindFirstUserResolver } from \\"./User/FindFirstUserResolver\\";
export { FindManyUserResolver } from \\"./User/FindManyUserResolver\\";
export { CreateUserResolver } from \\"./User/CreateUserResolver\\";
export { CreateManyUserResolver } from \\"./User/CreateManyUserResolver\\";
export { DeleteUserResolver } from \\"./User/DeleteUserResolver\\";
export { UpdateUserResolver } from \\"./User/UpdateUserResolver\\";
export { DeleteManyUserResolver } from \\"./User/DeleteManyUserResolver\\";
export { UpdateManyUserResolver } from \\"./User/UpdateManyUserResolver\\";
export { UpsertUserResolver } from \\"./User/UpsertUserResolver\\";
export { AggregateUserResolver } from \\"./User/AggregateUserResolver\\";
export { GroupByUserResolver } from \\"./User/GroupByUserResolver\\";
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: argsIndex 1`] = `
"export * from \\"./User/args\\";
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: crudIndex 1`] = `
"export { UserCrudResolver } from \\"./User/UserCrudResolver\\";
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: AggregateUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserOrderByInput } from \\"../../../inputs/UserOrderByInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class AggregateUserArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UserOrderByInput], {
    nullable: true
  })
  orderBy?: UserOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: true
  })
  cursor?: UserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: CreateManyUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserCreateManyInput } from \\"../../../inputs/UserCreateManyInput\\";

@TypeGraphQL.ArgsType()
export class CreateManyUserArgs {
  @TypeGraphQL.Field(_type => [UserCreateManyInput], {
    nullable: false
  })
  data!: UserCreateManyInput[];

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  skipDuplicates?: boolean | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: CreateUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserCreateInput } from \\"../../../inputs/UserCreateInput\\";

@TypeGraphQL.ArgsType()
export class CreateUserArgs {
  @TypeGraphQL.Field(_type => UserCreateInput, {
    nullable: false
  })
  data!: UserCreateInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: DeleteManyUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";

@TypeGraphQL.ArgsType()
export class DeleteManyUserArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: DeleteUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class DeleteUserArgs {
  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindFirstUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserOrderByInput } from \\"../../../inputs/UserOrderByInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";
import { UserScalarFieldEnum } from \\"../../../../enums/UserScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindFirstUserArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UserOrderByInput], {
    nullable: true
  })
  orderBy?: UserOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: true
  })
  cursor?: UserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [UserScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindManyUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserOrderByInput } from \\"../../../inputs/UserOrderByInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";
import { UserScalarFieldEnum } from \\"../../../../enums/UserScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindManyUserArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UserOrderByInput], {
    nullable: true
  })
  orderBy?: UserOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: true
  })
  cursor?: UserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [UserScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindUniqueUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class FindUniqueUserArgs {
  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: GroupByUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserOrderByInput } from \\"../../../inputs/UserOrderByInput\\";
import { UserScalarWhereWithAggregatesInput } from \\"../../../inputs/UserScalarWhereWithAggregatesInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";
import { UserScalarFieldEnum } from \\"../../../../enums/UserScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class GroupByUserArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UserOrderByInput], {
    nullable: true
  })
  orderBy?: UserOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => [UserScalarFieldEnum], {
    nullable: false
  })
  by!: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\">;

  @TypeGraphQL.Field(_type => UserScalarWhereWithAggregatesInput, {
    nullable: true
  })
  having?: UserScalarWhereWithAggregatesInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: Index 1`] = `
"export { AggregateUserArgs } from \\"./AggregateUserArgs\\";
export { CreateManyUserArgs } from \\"./CreateManyUserArgs\\";
export { CreateUserArgs } from \\"./CreateUserArgs\\";
export { DeleteManyUserArgs } from \\"./DeleteManyUserArgs\\";
export { DeleteUserArgs } from \\"./DeleteUserArgs\\";
export { FindFirstUserArgs } from \\"./FindFirstUserArgs\\";
export { FindManyUserArgs } from \\"./FindManyUserArgs\\";
export { FindUniqueUserArgs } from \\"./FindUniqueUserArgs\\";
export { GroupByUserArgs } from \\"./GroupByUserArgs\\";
export { UpdateManyUserArgs } from \\"./UpdateManyUserArgs\\";
export { UpdateUserArgs } from \\"./UpdateUserArgs\\";
export { UpsertUserArgs } from \\"./UpsertUserArgs\\";
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: UpdateManyUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUpdateManyMutationInput } from \\"../../../inputs/UserUpdateManyMutationInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";

@TypeGraphQL.ArgsType()
export class UpdateManyUserArgs {
  @TypeGraphQL.Field(_type => UserUpdateManyMutationInput, {
    nullable: false
  })
  data!: UserUpdateManyMutationInput;

  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: UpdateUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUpdateInput } from \\"../../../inputs/UserUpdateInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpdateUserArgs {
  @TypeGraphQL.Field(_type => UserUpdateInput, {
    nullable: false
  })
  data!: UserUpdateInput;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: UpsertUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserCreateInput } from \\"../../../inputs/UserCreateInput\\";
import { UserUpdateInput } from \\"../../../inputs/UserUpdateInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpsertUserArgs {
  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;

  @TypeGraphQL.Field(_type => UserCreateInput, {
    nullable: false
  })
  create!: UserCreateInput;

  @TypeGraphQL.Field(_type => UserUpdateInput, {
    nullable: false
  })
  update!: UserUpdateInput;
}
"
`;

exports[`crud should properly generate resolver class for single prisma model: Index 1`] = `
"export * from \\"./resolvers-actions.index\\";
export * from \\"./resolvers-crud.index\\";
export * from \\"./args.index\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: UserCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUserArgs } from \\"./args/AggregateUserArgs\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { CreateUserArgs } from \\"./args/CreateUserArgs\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { DeleteUserArgs } from \\"./args/DeleteUserArgs\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { UpdateUserArgs } from \\"./args/UpdateUserArgs\\";
import { UpsertUserArgs } from \\"./args/UpsertUserArgs\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateUser } from \\"../../outputs/AggregateUser\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";

@TypeGraphQL.Resolver(_of => User)
export class UserCrudResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async user(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUserArgs): Promise<User | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findFirstUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstUserArgs): Promise<User | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [User], {
    nullable: false
  })
  async users(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyUserArgs): Promise<User[]> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false
  })
  async createUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateUserArgs): Promise<User> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true
  })
  async deleteUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteUserArgs): Promise<User | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true
  })
  async updateUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateUserArgs): Promise<User | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false
  })
  async upsertUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertUserArgs): Promise<User> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => AggregateUser, {
    nullable: false
  })
  async aggregateUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateUserArgs): Promise<AggregateUser> {
    return getPrismaFromContext(ctx).user.aggregate({
      ...args,
      ...transformFields(graphqlFields(info as any)),
    });
  }

  @TypeGraphQL.Query(_returns => [UserGroupBy], {
    nullable: false
  })
  async groupByUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByUserArgs): Promise<UserGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }
}
"
`;

exports[`crud should properly generate resolver class for single prisma model: actionsIndex 1`] = `
"export { FindUniqueUserResolver } from \\"./User/FindUniqueUserResolver\\";
export { FindFirstUserResolver } from \\"./User/FindFirstUserResolver\\";
export { FindManyUserResolver } from \\"./User/FindManyUserResolver\\";
export { CreateUserResolver } from \\"./User/CreateUserResolver\\";
export { CreateManyUserResolver } from \\"./User/CreateManyUserResolver\\";
export { DeleteUserResolver } from \\"./User/DeleteUserResolver\\";
export { UpdateUserResolver } from \\"./User/UpdateUserResolver\\";
export { DeleteManyUserResolver } from \\"./User/DeleteManyUserResolver\\";
export { UpdateManyUserResolver } from \\"./User/UpdateManyUserResolver\\";
export { UpsertUserResolver } from \\"./User/UpsertUserResolver\\";
export { AggregateUserResolver } from \\"./User/AggregateUserResolver\\";
export { GroupByUserResolver } from \\"./User/GroupByUserResolver\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: argsIndex 1`] = `
"export * from \\"./User/args\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: crudIndex 1`] = `
"export { UserCrudResolver } from \\"./User/UserCrudResolver\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: mainIndex 1`] = `
"import { NonEmptyArray } from \\"type-graphql\\";
import * as crudResolversImport from \\"./resolvers/crud/resolvers-crud.index\\";

export * from \\"./enums\\";
export * from \\"./models\\";
export * from \\"./resolvers/crud\\";
export * from \\"./resolvers/inputs\\";
export * from \\"./resolvers/outputs\\";
export * from \\"./enhance\\";
export * from \\"./scalars\\";

export const crudResolvers = Object.values(crudResolversImport) as unknown as NonEmptyArray<Function>;
export const resolvers = [...crudResolvers] as unknown as NonEmptyArray<Function>;
"
`;

exports[`crud should properly generate resolver class when cannot pluralize model name: StaffCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateStaffArgs } from \\"./args/AggregateStaffArgs\\";
import { CreateManyStaffArgs } from \\"./args/CreateManyStaffArgs\\";
import { CreateStaffArgs } from \\"./args/CreateStaffArgs\\";
import { DeleteManyStaffArgs } from \\"./args/DeleteManyStaffArgs\\";
import { DeleteStaffArgs } from \\"./args/DeleteStaffArgs\\";
import { FindFirstStaffArgs } from \\"./args/FindFirstStaffArgs\\";
import { FindManyStaffArgs } from \\"./args/FindManyStaffArgs\\";
import { FindUniqueStaffArgs } from \\"./args/FindUniqueStaffArgs\\";
import { GroupByStaffArgs } from \\"./args/GroupByStaffArgs\\";
import { UpdateManyStaffArgs } from \\"./args/UpdateManyStaffArgs\\";
import { UpdateStaffArgs } from \\"./args/UpdateStaffArgs\\";
import { UpsertStaffArgs } from \\"./args/UpsertStaffArgs\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";
import { Staff } from \\"../../../models/Staff\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateStaff } from \\"../../outputs/AggregateStaff\\";
import { StaffGroupBy } from \\"../../outputs/StaffGroupBy\\";

@TypeGraphQL.Resolver(_of => Staff)
export class StaffCrudResolver {
  @TypeGraphQL.Query(_returns => Staff, {
    nullable: true
  })
  async findUniqueStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueStaffArgs): Promise<Staff | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).staff.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => Staff, {
    nullable: true
  })
  async findFirstStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstStaffArgs): Promise<Staff | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).staff.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [Staff], {
    nullable: false
  })
  async findManyStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyStaffArgs): Promise<Staff[]> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).staff.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: false
  })
  async createStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateStaffArgs): Promise<Staff> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).staff.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyStaffArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).staff.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: true
  })
  async deleteStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteStaffArgs): Promise<Staff | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).staff.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: true
  })
  async updateStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateStaffArgs): Promise<Staff | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).staff.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyStaffArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).staff.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyStaffArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).staff.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: false
  })
  async upsertStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertStaffArgs): Promise<Staff> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).staff.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => AggregateStaff, {
    nullable: false
  })
  async aggregateStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateStaffArgs): Promise<AggregateStaff> {
    return getPrismaFromContext(ctx).staff.aggregate({
      ...args,
      ...transformFields(graphqlFields(info as any)),
    });
  }

  @TypeGraphQL.Query(_returns => [StaffGroupBy], {
    nullable: false
  })
  async groupByStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByStaffArgs): Promise<StaffGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).staff.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }
}
"
`;

exports[`crud should properly generate resolver class when useOriginalMapping is used: FindUniqueUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { User } from \\"../../../models/User\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => User)
export class FindUniqueUserResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findUniqueUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUserArgs): Promise<User | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud should properly generate resolver class when useOriginalMapping is used: UserCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUserArgs } from \\"./args/AggregateUserArgs\\";
import { CreateManyUserArgs } from \\"./args/CreateManyUserArgs\\";
import { CreateUserArgs } from \\"./args/CreateUserArgs\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { DeleteUserArgs } from \\"./args/DeleteUserArgs\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { GroupByUserArgs } from \\"./args/GroupByUserArgs\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { UpdateUserArgs } from \\"./args/UpdateUserArgs\\";
import { UpsertUserArgs } from \\"./args/UpsertUserArgs\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";
import { User } from \\"../../../models/User\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateUser } from \\"../../outputs/AggregateUser\\";
import { UserGroupBy } from \\"../../outputs/UserGroupBy\\";

@TypeGraphQL.Resolver(_of => User)
export class UserCrudResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findUniqueUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUserArgs): Promise<User | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true
  })
  async findFirstUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstUserArgs): Promise<User | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [User], {
    nullable: false
  })
  async findManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyUserArgs): Promise<User[]> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false
  })
  async createUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateUserArgs): Promise<User> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true
  })
  async deleteUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteUserArgs): Promise<User | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true
  })
  async updateUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateUserArgs): Promise<User | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false
  })
  async upsertUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertUserArgs): Promise<User> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => AggregateUser, {
    nullable: false
  })
  async aggregateUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateUserArgs): Promise<AggregateUser> {
    return getPrismaFromContext(ctx).user.aggregate({
      ...args,
      ...transformFields(graphqlFields(info as any)),
    });
  }

  @TypeGraphQL.Query(_returns => [UserGroupBy], {
    nullable: false
  })
  async groupByUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByUserArgs): Promise<UserGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }
}
"
`;

exports[`crud when \`orderByAggregateGroup\` preview feature is enabled should properly generate args classes for group by action using aggregate input: GroupBySampleArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { SampleOrderByWithAggregationInput } from \\"../../../inputs/SampleOrderByWithAggregationInput\\";
import { SampleScalarWhereWithAggregatesInput } from \\"../../../inputs/SampleScalarWhereWithAggregatesInput\\";
import { SampleWhereInput } from \\"../../../inputs/SampleWhereInput\\";
import { SampleScalarFieldEnum } from \\"../../../../enums/SampleScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class GroupBySampleArgs {
  @TypeGraphQL.Field(_type => SampleWhereInput, {
    nullable: true
  })
  where?: SampleWhereInput | undefined;

  @TypeGraphQL.Field(_type => [SampleOrderByWithAggregationInput], {
    nullable: true
  })
  orderBy?: SampleOrderByWithAggregationInput[] | undefined;

  @TypeGraphQL.Field(_type => [SampleScalarFieldEnum], {
    nullable: false
  })
  by!: Array<\\"idField\\" | \\"stringField\\" | \\"floatField\\" | \\"intField\\" | \\"booleanField\\" | \\"dateField\\" | \\"jsonField\\">;

  @TypeGraphQL.Field(_type => SampleScalarWhereWithAggregatesInput, {
    nullable: true
  })
  having?: SampleScalarWhereWithAggregatesInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud when \`orderByRelation\` preview feature is enabled should properly generate args classes for sorting by many-to-many relation fields: AggregateFirstModelArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { FirstModelOrderByWithRelationInput } from \\"../../../inputs/FirstModelOrderByWithRelationInput\\";
import { FirstModelWhereInput } from \\"../../../inputs/FirstModelWhereInput\\";
import { FirstModelWhereUniqueInput } from \\"../../../inputs/FirstModelWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class AggregateFirstModelArgs {
  @TypeGraphQL.Field(_type => FirstModelWhereInput, {
    nullable: true
  })
  where?: FirstModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => [FirstModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: FirstModelOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => FirstModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: FirstModelWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud when \`orderByRelation\` preview feature is enabled should properly generate args classes for sorting by many-to-many relation fields: FindFirstFirstModelArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { FirstModelOrderByWithRelationInput } from \\"../../../inputs/FirstModelOrderByWithRelationInput\\";
import { FirstModelWhereInput } from \\"../../../inputs/FirstModelWhereInput\\";
import { FirstModelWhereUniqueInput } from \\"../../../inputs/FirstModelWhereUniqueInput\\";
import { FirstModelScalarFieldEnum } from \\"../../../../enums/FirstModelScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindFirstFirstModelArgs {
  @TypeGraphQL.Field(_type => FirstModelWhereInput, {
    nullable: true
  })
  where?: FirstModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => [FirstModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: FirstModelOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => FirstModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: FirstModelWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [FirstModelScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"idField\\" | \\"uniqueStringField\\" | \\"floatField\\"> | undefined;
}
"
`;

exports[`crud when \`orderByRelation\` preview feature is enabled should properly generate args classes for sorting by many-to-many relation fields: FindManyFirstModelArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { FirstModelOrderByWithRelationInput } from \\"../../../inputs/FirstModelOrderByWithRelationInput\\";
import { FirstModelWhereInput } from \\"../../../inputs/FirstModelWhereInput\\";
import { FirstModelWhereUniqueInput } from \\"../../../inputs/FirstModelWhereUniqueInput\\";
import { FirstModelScalarFieldEnum } from \\"../../../../enums/FirstModelScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindManyFirstModelArgs {
  @TypeGraphQL.Field(_type => FirstModelWhereInput, {
    nullable: true
  })
  where?: FirstModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => [FirstModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: FirstModelOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => FirstModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: FirstModelWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [FirstModelScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"idField\\" | \\"uniqueStringField\\" | \\"floatField\\"> | undefined;
}
"
`;

exports[`crud when \`orderByRelation\` preview feature is enabled should properly generate args classes for sorting by many-to-many relation fields: index 1`] = `
"export { AggregateFirstModelArgs } from \\"./AggregateFirstModelArgs\\";
export { CreateFirstModelArgs } from \\"./CreateFirstModelArgs\\";
export { CreateManyFirstModelArgs } from \\"./CreateManyFirstModelArgs\\";
export { DeleteFirstModelArgs } from \\"./DeleteFirstModelArgs\\";
export { DeleteManyFirstModelArgs } from \\"./DeleteManyFirstModelArgs\\";
export { FindFirstFirstModelArgs } from \\"./FindFirstFirstModelArgs\\";
export { FindManyFirstModelArgs } from \\"./FindManyFirstModelArgs\\";
export { FindUniqueFirstModelArgs } from \\"./FindUniqueFirstModelArgs\\";
export { GroupByFirstModelArgs } from \\"./GroupByFirstModelArgs\\";
export { UpdateFirstModelArgs } from \\"./UpdateFirstModelArgs\\";
export { UpdateManyFirstModelArgs } from \\"./UpdateManyFirstModelArgs\\";
export { UpsertFirstModelArgs } from \\"./UpsertFirstModelArgs\\";
"
`;

exports[`crud when \`orderByRelation\` preview feature is enabled should properly generate args classes for sorting by one-to-many relation fields: AggregateSecondModelArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { SecondModelOrderByWithRelationInput } from \\"../../../inputs/SecondModelOrderByWithRelationInput\\";
import { SecondModelWhereInput } from \\"../../../inputs/SecondModelWhereInput\\";
import { SecondModelWhereUniqueInput } from \\"../../../inputs/SecondModelWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class AggregateSecondModelArgs {
  @TypeGraphQL.Field(_type => SecondModelWhereInput, {
    nullable: true
  })
  where?: SecondModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => [SecondModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: SecondModelOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => SecondModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: SecondModelWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud when \`orderByRelation\` preview feature is enabled should properly generate args classes for sorting by one-to-many relation fields: FindFirstSecondModelArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { SecondModelOrderByWithRelationInput } from \\"../../../inputs/SecondModelOrderByWithRelationInput\\";
import { SecondModelWhereInput } from \\"../../../inputs/SecondModelWhereInput\\";
import { SecondModelWhereUniqueInput } from \\"../../../inputs/SecondModelWhereUniqueInput\\";
import { SecondModelScalarFieldEnum } from \\"../../../../enums/SecondModelScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindFirstSecondModelArgs {
  @TypeGraphQL.Field(_type => SecondModelWhereInput, {
    nullable: true
  })
  where?: SecondModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => [SecondModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: SecondModelOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => SecondModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: SecondModelWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [SecondModelScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"idField\\" | \\"uniqueStringField\\" | \\"floatField\\" | \\"firstModelFieldId\\"> | undefined;
}
"
`;

exports[`crud when \`orderByRelation\` preview feature is enabled should properly generate args classes for sorting by one-to-many relation fields: FindManySecondModelArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { SecondModelOrderByWithRelationInput } from \\"../../../inputs/SecondModelOrderByWithRelationInput\\";
import { SecondModelWhereInput } from \\"../../../inputs/SecondModelWhereInput\\";
import { SecondModelWhereUniqueInput } from \\"../../../inputs/SecondModelWhereUniqueInput\\";
import { SecondModelScalarFieldEnum } from \\"../../../../enums/SecondModelScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindManySecondModelArgs {
  @TypeGraphQL.Field(_type => SecondModelWhereInput, {
    nullable: true
  })
  where?: SecondModelWhereInput | undefined;

  @TypeGraphQL.Field(_type => [SecondModelOrderByWithRelationInput], {
    nullable: true
  })
  orderBy?: SecondModelOrderByWithRelationInput[] | undefined;

  @TypeGraphQL.Field(_type => SecondModelWhereUniqueInput, {
    nullable: true
  })
  cursor?: SecondModelWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [SecondModelScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"idField\\" | \\"uniqueStringField\\" | \\"floatField\\" | \\"firstModelFieldId\\"> | undefined;
}
"
`;

exports[`crud when \`orderByRelation\` preview feature is enabled should properly generate args classes for sorting by one-to-many relation fields: index 1`] = `
"export { AggregateSecondModelArgs } from \\"./AggregateSecondModelArgs\\";
export { CreateManySecondModelArgs } from \\"./CreateManySecondModelArgs\\";
export { CreateSecondModelArgs } from \\"./CreateSecondModelArgs\\";
export { DeleteManySecondModelArgs } from \\"./DeleteManySecondModelArgs\\";
export { DeleteSecondModelArgs } from \\"./DeleteSecondModelArgs\\";
export { FindFirstSecondModelArgs } from \\"./FindFirstSecondModelArgs\\";
export { FindManySecondModelArgs } from \\"./FindManySecondModelArgs\\";
export { FindUniqueSecondModelArgs } from \\"./FindUniqueSecondModelArgs\\";
export { GroupBySecondModelArgs } from \\"./GroupBySecondModelArgs\\";
export { UpdateManySecondModelArgs } from \\"./UpdateManySecondModelArgs\\";
export { UpdateSecondModelArgs } from \\"./UpdateSecondModelArgs\\";
export { UpsertSecondModelArgs } from \\"./UpsertSecondModelArgs\\";
"
`;

exports[`crud when emitTranspiledCode is set to true should properly generate imports in js files for resolver classes: UserCrudResolver 1`] = `
"\\"use strict\\";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, \\"default\\", { enumerable: true, value: v });
}) : function(o, v) {
    o[\\"default\\"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === \\"object\\" && typeof Reflect.decorate === \\"function\\") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== \\"default\\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === \\"object\\" && typeof Reflect.metadata === \\"function\\") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { \\"default\\": mod };
};
Object.defineProperty(exports, \\"__esModule\\", { value: true });
exports.UserCrudResolver = void 0;
const TypeGraphQL = __importStar(require(\\"type-graphql\\"));
const graphql_fields_1 = __importDefault(require(\\"graphql-fields\\"));
const AggregateUserArgs_1 = require(\\"./args/AggregateUserArgs\\");
const CreateManyUserArgs_1 = require(\\"./args/CreateManyUserArgs\\");
const CreateUserArgs_1 = require(\\"./args/CreateUserArgs\\");
const DeleteManyUserArgs_1 = require(\\"./args/DeleteManyUserArgs\\");
const DeleteUserArgs_1 = require(\\"./args/DeleteUserArgs\\");
const FindFirstUserArgs_1 = require(\\"./args/FindFirstUserArgs\\");
const FindManyUserArgs_1 = require(\\"./args/FindManyUserArgs\\");
const FindUniqueUserArgs_1 = require(\\"./args/FindUniqueUserArgs\\");
const GroupByUserArgs_1 = require(\\"./args/GroupByUserArgs\\");
const UpdateManyUserArgs_1 = require(\\"./args/UpdateManyUserArgs\\");
const UpdateUserArgs_1 = require(\\"./args/UpdateUserArgs\\");
const UpsertUserArgs_1 = require(\\"./args/UpsertUserArgs\\");
const helpers_1 = require(\\"../../../helpers\\");
const User_1 = require(\\"../../../models/User\\");
const AffectedRowsOutput_1 = require(\\"../../outputs/AffectedRowsOutput\\");
const AggregateUser_1 = require(\\"../../outputs/AggregateUser\\");
const UserGroupBy_1 = require(\\"../../outputs/UserGroupBy\\");
let UserCrudResolver = class UserCrudResolver {
    async user(ctx, info, args) {
        const { _count } = helpers_1.transformFields(graphql_fields_1.default(info));
        return helpers_1.getPrismaFromContext(ctx).user.findUnique({
            ...args,
            ...(_count && helpers_1.transformCountFieldIntoSelectRelationsCount(_count)),
        });
    }
    async findFirstUser(ctx, info, args) {
        const { _count } = helpers_1.transformFields(graphql_fields_1.default(info));
        return helpers_1.getPrismaFromContext(ctx).user.findFirst({
            ...args,
            ...(_count && helpers_1.transformCountFieldIntoSelectRelationsCount(_count)),
        });
    }
    async users(ctx, info, args) {
        const { _count } = helpers_1.transformFields(graphql_fields_1.default(info));
        return helpers_1.getPrismaFromContext(ctx).user.findMany({
            ...args,
            ...(_count && helpers_1.transformCountFieldIntoSelectRelationsCount(_count)),
        });
    }
    async createUser(ctx, info, args) {
        const { _count } = helpers_1.transformFields(graphql_fields_1.default(info));
        return helpers_1.getPrismaFromContext(ctx).user.create({
            ...args,
            ...(_count && helpers_1.transformCountFieldIntoSelectRelationsCount(_count)),
        });
    }
    async createManyUser(ctx, info, args) {
        const { _count } = helpers_1.transformFields(graphql_fields_1.default(info));
        return helpers_1.getPrismaFromContext(ctx).user.createMany({
            ...args,
            ...(_count && helpers_1.transformCountFieldIntoSelectRelationsCount(_count)),
        });
    }
    async deleteUser(ctx, info, args) {
        const { _count } = helpers_1.transformFields(graphql_fields_1.default(info));
        return helpers_1.getPrismaFromContext(ctx).user.delete({
            ...args,
            ...(_count && helpers_1.transformCountFieldIntoSelectRelationsCount(_count)),
        });
    }
    async updateUser(ctx, info, args) {
        const { _count } = helpers_1.transformFields(graphql_fields_1.default(info));
        return helpers_1.getPrismaFromContext(ctx).user.update({
            ...args,
            ...(_count && helpers_1.transformCountFieldIntoSelectRelationsCount(_count)),
        });
    }
    async deleteManyUser(ctx, info, args) {
        const { _count } = helpers_1.transformFields(graphql_fields_1.default(info));
        return helpers_1.getPrismaFromContext(ctx).user.deleteMany({
            ...args,
            ...(_count && helpers_1.transformCountFieldIntoSelectRelationsCount(_count)),
        });
    }
    async updateManyUser(ctx, info, args) {
        const { _count } = helpers_1.transformFields(graphql_fields_1.default(info));
        return helpers_1.getPrismaFromContext(ctx).user.updateMany({
            ...args,
            ...(_count && helpers_1.transformCountFieldIntoSelectRelationsCount(_count)),
        });
    }
    async upsertUser(ctx, info, args) {
        const { _count } = helpers_1.transformFields(graphql_fields_1.default(info));
        return helpers_1.getPrismaFromContext(ctx).user.upsert({
            ...args,
            ...(_count && helpers_1.transformCountFieldIntoSelectRelationsCount(_count)),
        });
    }
    async aggregateUser(ctx, info, args) {
        return helpers_1.getPrismaFromContext(ctx).user.aggregate({
            ...args,
            ...helpers_1.transformFields(graphql_fields_1.default(info)),
        });
    }
    async groupByUser(ctx, info, args) {
        const { _count, _avg, _sum, _min, _max } = helpers_1.transformFields(graphql_fields_1.default(info));
        return helpers_1.getPrismaFromContext(ctx).user.groupBy({
            ...args,
            ...Object.fromEntries(Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)),
        });
    }
};
__decorate([
    TypeGraphQL.Query(_returns => User_1.User, {
        nullable: true
    }),
    __param(0, TypeGraphQL.Ctx()),
    __param(1, TypeGraphQL.Info()),
    __param(2, TypeGraphQL.Args()),
    __metadata(\\"design:type\\", Function),
    __metadata(\\"design:paramtypes\\", [Object, Object, FindUniqueUserArgs_1.FindUniqueUserArgs]),
    __metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"user\\", null);
__decorate([
    TypeGraphQL.Query(_returns => User_1.User, {
        nullable: true
    }),
    __param(0, TypeGraphQL.Ctx()),
    __param(1, TypeGraphQL.Info()),
    __param(2, TypeGraphQL.Args()),
    __metadata(\\"design:type\\", Function),
    __metadata(\\"design:paramtypes\\", [Object, Object, FindFirstUserArgs_1.FindFirstUserArgs]),
    __metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"findFirstUser\\", null);
__decorate([
    TypeGraphQL.Query(_returns => [User_1.User], {
        nullable: false
    }),
    __param(0, TypeGraphQL.Ctx()),
    __param(1, TypeGraphQL.Info()),
    __param(2, TypeGraphQL.Args()),
    __metadata(\\"design:type\\", Function),
    __metadata(\\"design:paramtypes\\", [Object, Object, FindManyUserArgs_1.FindManyUserArgs]),
    __metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"users\\", null);
__decorate([
    TypeGraphQL.Mutation(_returns => User_1.User, {
        nullable: false
    }),
    __param(0, TypeGraphQL.Ctx()),
    __param(1, TypeGraphQL.Info()),
    __param(2, TypeGraphQL.Args()),
    __metadata(\\"design:type\\", Function),
    __metadata(\\"design:paramtypes\\", [Object, Object, CreateUserArgs_1.CreateUserArgs]),
    __metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"createUser\\", null);
__decorate([
    TypeGraphQL.Mutation(_returns => AffectedRowsOutput_1.AffectedRowsOutput, {
        nullable: false
    }),
    __param(0, TypeGraphQL.Ctx()),
    __param(1, TypeGraphQL.Info()),
    __param(2, TypeGraphQL.Args()),
    __metadata(\\"design:type\\", Function),
    __metadata(\\"design:paramtypes\\", [Object, Object, CreateManyUserArgs_1.CreateManyUserArgs]),
    __metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"createManyUser\\", null);
__decorate([
    TypeGraphQL.Mutation(_returns => User_1.User, {
        nullable: true
    }),
    __param(0, TypeGraphQL.Ctx()),
    __param(1, TypeGraphQL.Info()),
    __param(2, TypeGraphQL.Args()),
    __metadata(\\"design:type\\", Function),
    __metadata(\\"design:paramtypes\\", [Object, Object, DeleteUserArgs_1.DeleteUserArgs]),
    __metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"deleteUser\\", null);
__decorate([
    TypeGraphQL.Mutation(_returns => User_1.User, {
        nullable: true
    }),
    __param(0, TypeGraphQL.Ctx()),
    __param(1, TypeGraphQL.Info()),
    __param(2, TypeGraphQL.Args()),
    __metadata(\\"design:type\\", Function),
    __metadata(\\"design:paramtypes\\", [Object, Object, UpdateUserArgs_1.UpdateUserArgs]),
    __metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"updateUser\\", null);
__decorate([
    TypeGraphQL.Mutation(_returns => AffectedRowsOutput_1.AffectedRowsOutput, {
        nullable: false
    }),
    __param(0, TypeGraphQL.Ctx()),
    __param(1, TypeGraphQL.Info()),
    __param(2, TypeGraphQL.Args()),
    __metadata(\\"design:type\\", Function),
    __metadata(\\"design:paramtypes\\", [Object, Object, DeleteManyUserArgs_1.DeleteManyUserArgs]),
    __metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"deleteManyUser\\", null);
__decorate([
    TypeGraphQL.Mutation(_returns => AffectedRowsOutput_1.AffectedRowsOutput, {
        nullable: false
    }),
    __param(0, TypeGraphQL.Ctx()),
    __param(1, TypeGraphQL.Info()),
    __param(2, TypeGraphQL.Args()),
    __metadata(\\"design:type\\", Function),
    __metadata(\\"design:paramtypes\\", [Object, Object, UpdateManyUserArgs_1.UpdateManyUserArgs]),
    __metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"updateManyUser\\", null);
__decorate([
    TypeGraphQL.Mutation(_returns => User_1.User, {
        nullable: false
    }),
    __param(0, TypeGraphQL.Ctx()),
    __param(1, TypeGraphQL.Info()),
    __param(2, TypeGraphQL.Args()),
    __metadata(\\"design:type\\", Function),
    __metadata(\\"design:paramtypes\\", [Object, Object, UpsertUserArgs_1.UpsertUserArgs]),
    __metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"upsertUser\\", null);
__decorate([
    TypeGraphQL.Query(_returns => AggregateUser_1.AggregateUser, {
        nullable: false
    }),
    __param(0, TypeGraphQL.Ctx()),
    __param(1, TypeGraphQL.Info()),
    __param(2, TypeGraphQL.Args()),
    __metadata(\\"design:type\\", Function),
    __metadata(\\"design:paramtypes\\", [Object, Object, AggregateUserArgs_1.AggregateUserArgs]),
    __metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"aggregateUser\\", null);
__decorate([
    TypeGraphQL.Query(_returns => [UserGroupBy_1.UserGroupBy], {
        nullable: false
    }),
    __param(0, TypeGraphQL.Ctx()),
    __param(1, TypeGraphQL.Info()),
    __param(2, TypeGraphQL.Args()),
    __metadata(\\"design:type\\", Function),
    __metadata(\\"design:paramtypes\\", [Object, Object, GroupByUserArgs_1.GroupByUserArgs]),
    __metadata(\\"design:returntype\\", Promise)
], UserCrudResolver.prototype, \\"groupByUser\\", null);
UserCrudResolver = __decorate([
    TypeGraphQL.Resolver(_of => User_1.User)
], UserCrudResolver);
exports.UserCrudResolver = UserCrudResolver;
"
`;

exports[`crud when model has prefix should properly generate actions resolver classes for prisma model: AggregateUUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUUserArgs } from \\"./args/AggregateUUserArgs\\";
import { UUser } from \\"../../../models/UUser\\";
import { AggregateUUser } from \\"../../outputs/AggregateUUser\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => UUser)
export class AggregateUUserResolver {
  @TypeGraphQL.Query(_returns => AggregateUUser, {
    nullable: false
  })
  async aggregateUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateUUserArgs): Promise<AggregateUUUser> {
    return getPrismaFromContext(ctx).user.aggregate({
      ...args,
      ...transformFields(graphqlFields(info as any)),
    });
  }
}
"
`;

exports[`crud when model has prefix should properly generate actions resolver classes for prisma model: CreateManyUUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { CreateManyUUserArgs } from \\"./args/CreateManyUUserArgs\\";
import { UUser } from \\"../../../models/UUser\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => UUser)
export class CreateManyUUserResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyUUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model has prefix should properly generate actions resolver classes for prisma model: CreateOneUUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { CreateUUserArgs } from \\"./args/CreateUUserArgs\\";
import { UUser } from \\"../../../models/UUser\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => UUser)
export class CreateUUserResolver {
  @TypeGraphQL.Mutation(_returns => UUser, {
    nullable: false
  })
  async createUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateUUserArgs): Promise<UUser> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model has prefix should properly generate actions resolver classes for prisma model: DeleteManyUUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { DeleteManyUUserArgs } from \\"./args/DeleteManyUUserArgs\\";
import { UUser } from \\"../../../models/UUser\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => UUser)
export class DeleteManyUUserResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyUUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model has prefix should properly generate actions resolver classes for prisma model: DeleteUUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { DeleteUUserArgs } from \\"./args/DeleteUUserArgs\\";
import { UUser } from \\"../../../models/UUser\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => UUser)
export class DeleteUUserResolver {
  @TypeGraphQL.Mutation(_returns => UUser, {
    nullable: true
  })
  async deleteUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteUUserArgs): Promise<UUser | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model has prefix should properly generate actions resolver classes for prisma model: FindFirstUUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { FindFirstUUserArgs } from \\"./args/FindFirstUUserArgs\\";
import { UUser } from \\"../../../models/UUser\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => UUser)
export class FindFirstUUserResolver {
  @TypeGraphQL.Query(_returns => UUser, {
    nullable: true
  })
  async findFirstUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstUUserArgs): Promise<UUser | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model has prefix should properly generate actions resolver classes for prisma model: FindManyUUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { FindManyUUserArgs } from \\"./args/FindManyUUserArgs\\";
import { UUser } from \\"../../../models/UUser\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => UUser)
export class FindManyUUserResolver {
  @TypeGraphQL.Query(_returns => [UUser], {
    nullable: false
  })
  async uUsers(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyUUserArgs): Promise<UUser[]> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model has prefix should properly generate actions resolver classes for prisma model: FindUniqueUUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { FindUniqueUUserArgs } from \\"./args/FindUniqueUUserArgs\\";
import { UUser } from \\"../../../models/UUser\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => UUser)
export class FindUniqueUUserResolver {
  @TypeGraphQL.Query(_returns => UUser, {
    nullable: true
  })
  async uUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUUserArgs): Promise<UUser | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model has prefix should properly generate actions resolver classes for prisma model: GroupByUUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { GroupByUUserArgs } from \\"./args/GroupByUUserArgs\\";
import { UUser } from \\"../../../models/UUser\\";
import { UUserGroupBy } from \\"../../outputs/UUserGroupBy\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => UUser)
export class GroupByUUserResolver {
  @TypeGraphQL.Query(_returns => [UUserGroupBy], {
    nullable: false
  })
  async groupByUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByUUserArgs): Promise<UUUserGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }
}
"
`;

exports[`crud when model has prefix should properly generate actions resolver classes for prisma model: UpdateManyUUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { UpdateManyUUserArgs } from \\"./args/UpdateManyUUserArgs\\";
import { UUser } from \\"../../../models/UUser\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => UUser)
export class UpdateManyUUserResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyUUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model has prefix should properly generate actions resolver classes for prisma model: UpdateUUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { UpdateUUserArgs } from \\"./args/UpdateUUserArgs\\";
import { UUser } from \\"../../../models/UUser\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => UUser)
export class UpdateUUserResolver {
  @TypeGraphQL.Mutation(_returns => UUser, {
    nullable: true
  })
  async updateUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateUUserArgs): Promise<UUser | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model has prefix should properly generate actions resolver classes for prisma model: UpsertUUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { UpsertUUserArgs } from \\"./args/UpsertUUserArgs\\";
import { UUser } from \\"../../../models/UUser\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => UUser)
export class UpsertUUserResolver {
  @TypeGraphQL.Mutation(_returns => UUser, {
    nullable: false
  })
  async upsertUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertUUserArgs): Promise<UUser> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model has prefix should properly generate args classes for every method of crud resolver: AggregateUUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UUserOrderByInput } from \\"../../../inputs/UUserOrderByInput\\";
import { UUserWhereInput } from \\"../../../inputs/UUserWhereInput\\";
import { UUserWhereUniqueInput } from \\"../../../inputs/UUserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class AggregateUUserArgs {
  @TypeGraphQL.Field(_type => UUserWhereInput, {
    nullable: true
  })
  where?: UUserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UUserOrderByInput], {
    nullable: true
  })
  orderBy?: UUserOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => UUserWhereUniqueInput, {
    nullable: true
  })
  cursor?: UUserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud when model has prefix should properly generate args classes for every method of crud resolver: CreateManyUUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UUserCreateManyInput } from \\"../../../inputs/UUserCreateManyInput\\";

@TypeGraphQL.ArgsType()
export class CreateManyUUserArgs {
  @TypeGraphQL.Field(_type => [UUserCreateManyInput], {
    nullable: false
  })
  data!: UUserCreateManyInput[];

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  skipDuplicates?: boolean | undefined;
}
"
`;

exports[`crud when model has prefix should properly generate args classes for every method of crud resolver: CreateUUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UUserCreateInput } from \\"../../../inputs/UUserCreateInput\\";

@TypeGraphQL.ArgsType()
export class CreateUUserArgs {
  @TypeGraphQL.Field(_type => UUserCreateInput, {
    nullable: false
  })
  data!: UUserCreateInput;
}
"
`;

exports[`crud when model has prefix should properly generate args classes for every method of crud resolver: DeleteManyUUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UUserWhereInput } from \\"../../../inputs/UUserWhereInput\\";

@TypeGraphQL.ArgsType()
export class DeleteManyUUserArgs {
  @TypeGraphQL.Field(_type => UUserWhereInput, {
    nullable: true
  })
  where?: UUserWhereInput | undefined;
}
"
`;

exports[`crud when model has prefix should properly generate args classes for every method of crud resolver: DeleteUUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UUserWhereUniqueInput } from \\"../../../inputs/UUserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class DeleteUUserArgs {
  @TypeGraphQL.Field(_type => UUserWhereUniqueInput, {
    nullable: false
  })
  where!: UUserWhereUniqueInput;
}
"
`;

exports[`crud when model has prefix should properly generate args classes for every method of crud resolver: FindFirstUUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UUserOrderByInput } from \\"../../../inputs/UUserOrderByInput\\";
import { UUserWhereInput } from \\"../../../inputs/UUserWhereInput\\";
import { UUserWhereUniqueInput } from \\"../../../inputs/UUserWhereUniqueInput\\";
import { UUserScalarFieldEnum } from \\"../../../../enums/UUserScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindFirstUUserArgs {
  @TypeGraphQL.Field(_type => UUserWhereInput, {
    nullable: true
  })
  where?: UUserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UUserOrderByInput], {
    nullable: true
  })
  orderBy?: UUserOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => UUserWhereUniqueInput, {
    nullable: true
  })
  cursor?: UUserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [UUserScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud when model has prefix should properly generate args classes for every method of crud resolver: FindManyUUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UUserOrderByInput } from \\"../../../inputs/UUserOrderByInput\\";
import { UUserWhereInput } from \\"../../../inputs/UUserWhereInput\\";
import { UUserWhereUniqueInput } from \\"../../../inputs/UUserWhereUniqueInput\\";
import { UUserScalarFieldEnum } from \\"../../../../enums/UUserScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindManyUUserArgs {
  @TypeGraphQL.Field(_type => UUserWhereInput, {
    nullable: true
  })
  where?: UUserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UUserOrderByInput], {
    nullable: true
  })
  orderBy?: UUserOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => UUserWhereUniqueInput, {
    nullable: true
  })
  cursor?: UUserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [UUserScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud when model has prefix should properly generate args classes for every method of crud resolver: FindUniqueUUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UUserWhereUniqueInput } from \\"../../../inputs/UUserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class FindUniqueUUserArgs {
  @TypeGraphQL.Field(_type => UUserWhereUniqueInput, {
    nullable: false
  })
  where!: UUserWhereUniqueInput;
}
"
`;

exports[`crud when model has prefix should properly generate args classes for every method of crud resolver: GroupByUUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UUserOrderByInput } from \\"../../../inputs/UUserOrderByInput\\";
import { UUserScalarWhereWithAggregatesInput } from \\"../../../inputs/UUserScalarWhereWithAggregatesInput\\";
import { UUserWhereInput } from \\"../../../inputs/UUserWhereInput\\";
import { UUserScalarFieldEnum } from \\"../../../../enums/UUserScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class GroupByUUserArgs {
  @TypeGraphQL.Field(_type => UUserWhereInput, {
    nullable: true
  })
  where?: UUserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UUserOrderByInput], {
    nullable: true
  })
  orderBy?: UUserOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => [UUserScalarFieldEnum], {
    nullable: false
  })
  by!: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\">;

  @TypeGraphQL.Field(_type => UUserScalarWhereWithAggregatesInput, {
    nullable: true
  })
  having?: UUserScalarWhereWithAggregatesInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud when model has prefix should properly generate args classes for every method of crud resolver: Index 1`] = `
"export { AggregateUUserArgs } from \\"./AggregateUUserArgs\\";
export { CreateManyUUserArgs } from \\"./CreateManyUUserArgs\\";
export { CreateUUserArgs } from \\"./CreateUUserArgs\\";
export { DeleteManyUUserArgs } from \\"./DeleteManyUUserArgs\\";
export { DeleteUUserArgs } from \\"./DeleteUUserArgs\\";
export { FindFirstUUserArgs } from \\"./FindFirstUUserArgs\\";
export { FindManyUUserArgs } from \\"./FindManyUUserArgs\\";
export { FindUniqueUUserArgs } from \\"./FindUniqueUUserArgs\\";
export { GroupByUUserArgs } from \\"./GroupByUUserArgs\\";
export { UpdateManyUUserArgs } from \\"./UpdateManyUUserArgs\\";
export { UpdateUUserArgs } from \\"./UpdateUUserArgs\\";
export { UpsertUUserArgs } from \\"./UpsertUUserArgs\\";
"
`;

exports[`crud when model has prefix should properly generate args classes for every method of crud resolver: UpdateManyUUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UUserUpdateManyMutationInput } from \\"../../../inputs/UUserUpdateManyMutationInput\\";
import { UUserWhereInput } from \\"../../../inputs/UUserWhereInput\\";

@TypeGraphQL.ArgsType()
export class UpdateManyUUserArgs {
  @TypeGraphQL.Field(_type => UUserUpdateManyMutationInput, {
    nullable: false
  })
  data!: UUserUpdateManyMutationInput;

  @TypeGraphQL.Field(_type => UUserWhereInput, {
    nullable: true
  })
  where?: UUserWhereInput | undefined;
}
"
`;

exports[`crud when model has prefix should properly generate args classes for every method of crud resolver: UpdateUUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UUserUpdateInput } from \\"../../../inputs/UUserUpdateInput\\";
import { UUserWhereUniqueInput } from \\"../../../inputs/UUserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpdateUUserArgs {
  @TypeGraphQL.Field(_type => UUserUpdateInput, {
    nullable: false
  })
  data!: UUserUpdateInput;

  @TypeGraphQL.Field(_type => UUserWhereUniqueInput, {
    nullable: false
  })
  where!: UUserWhereUniqueInput;
}
"
`;

exports[`crud when model has prefix should properly generate args classes for every method of crud resolver: UpsertUUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UUserCreateInput } from \\"../../../inputs/UUserCreateInput\\";
import { UUserUpdateInput } from \\"../../../inputs/UUserUpdateInput\\";
import { UUserWhereUniqueInput } from \\"../../../inputs/UUserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpsertUUserArgs {
  @TypeGraphQL.Field(_type => UUserWhereUniqueInput, {
    nullable: false
  })
  where!: UUserWhereUniqueInput;

  @TypeGraphQL.Field(_type => UUserCreateInput, {
    nullable: false
  })
  create!: UUserCreateInput;

  @TypeGraphQL.Field(_type => UUserUpdateInput, {
    nullable: false
  })
  update!: UUserUpdateInput;
}
"
`;

exports[`crud when model has prefix should properly generate resolver class for single prisma model: UUserCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUUserArgs } from \\"./args/AggregateUUserArgs\\";
import { CreateManyUUserArgs } from \\"./args/CreateManyUUserArgs\\";
import { CreateUUserArgs } from \\"./args/CreateUUserArgs\\";
import { DeleteManyUUserArgs } from \\"./args/DeleteManyUUserArgs\\";
import { DeleteUUserArgs } from \\"./args/DeleteUUserArgs\\";
import { FindFirstUUserArgs } from \\"./args/FindFirstUUserArgs\\";
import { FindManyUUserArgs } from \\"./args/FindManyUUserArgs\\";
import { FindUniqueUUserArgs } from \\"./args/FindUniqueUUserArgs\\";
import { GroupByUUserArgs } from \\"./args/GroupByUUserArgs\\";
import { UpdateManyUUserArgs } from \\"./args/UpdateManyUUserArgs\\";
import { UpdateUUserArgs } from \\"./args/UpdateUUserArgs\\";
import { UpsertUUserArgs } from \\"./args/UpsertUUserArgs\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";
import { UUser } from \\"../../../models/UUser\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateUUser } from \\"../../outputs/AggregateUUser\\";
import { UUserGroupBy } from \\"../../outputs/UUserGroupBy\\";

@TypeGraphQL.Resolver(_of => UUser)
export class UUserCrudResolver {
  @TypeGraphQL.Query(_returns => UUser, {
    nullable: true
  })
  async findUniqueUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueUUserArgs): Promise<UUser | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => UUser, {
    nullable: true
  })
  async findFirstUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstUUserArgs): Promise<UUser | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [UUser], {
    nullable: false
  })
  async findManyUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyUUserArgs): Promise<UUser[]> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => UUser, {
    nullable: false
  })
  async createUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateUUserArgs): Promise<UUser> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyUUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => UUser, {
    nullable: true
  })
  async deleteUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteUUserArgs): Promise<UUser | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => UUser, {
    nullable: true
  })
  async updateUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateUUserArgs): Promise<UUser | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyUUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyUUserArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => UUser, {
    nullable: false
  })
  async upsertUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertUUserArgs): Promise<UUser> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => AggregateUUser, {
    nullable: false
  })
  async aggregateUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateUUserArgs): Promise<AggregateUUUser> {
    return getPrismaFromContext(ctx).user.aggregate({
      ...args,
      ...transformFields(graphqlFields(info as any)),
    });
  }

  @TypeGraphQL.Query(_returns => [UUserGroupBy], {
    nullable: false
  })
  async groupByUUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByUUserArgs): Promise<UUUserGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: CreateManyClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { CreateManyClientArgs } from \\"./args/CreateManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class CreateManyClientResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyClientArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: CreateOneClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { CreateClientArgs } from \\"./args/CreateClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class CreateClientResolver {
  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: false
  })
  async createClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateClientArgs): Promise<Client> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: DeleteClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { DeleteClientArgs } from \\"./args/DeleteClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class DeleteClientResolver {
  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: true
  })
  async deleteClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteClientArgs): Promise<Client | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: DeleteManyClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { DeleteManyClientArgs } from \\"./args/DeleteManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class DeleteManyClientResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyClientArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: FindFirstClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { FindFirstClientArgs } from \\"./args/FindFirstClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class FindFirstClientResolver {
  @TypeGraphQL.Query(_returns => Client, {
    nullable: true
  })
  async findFirstClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstClientArgs): Promise<Client | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: FindManyClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { FindManyClientArgs } from \\"./args/FindManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class FindManyClientResolver {
  @TypeGraphQL.Query(_returns => [Client], {
    nullable: false
  })
  async clients(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyClientArgs): Promise<Client[]> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: FindUniqueClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { FindUniqueClientArgs } from \\"./args/FindUniqueClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class FindUniqueClientResolver {
  @TypeGraphQL.Query(_returns => Client, {
    nullable: true
  })
  async client(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueClientArgs): Promise<Client | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: GroupByClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { GroupByClientArgs } from \\"./args/GroupByClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { ClientGroupBy } from \\"../../outputs/ClientGroupBy\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class GroupByClientResolver {
  @TypeGraphQL.Query(_returns => [ClientGroupBy], {
    nullable: false
  })
  async groupByClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByClientArgs): Promise<ClientGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: UpdateClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { UpdateClientArgs } from \\"./args/UpdateClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class UpdateClientResolver {
  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: true
  })
  async updateClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateClientArgs): Promise<Client | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: UpdateManyClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { UpdateManyClientArgs } from \\"./args/UpdateManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class UpdateManyClientResolver {
  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyClientArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: UpsertClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { UpsertClientArgs } from \\"./args/UpsertClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";

@TypeGraphQL.Resolver(_of => Client)
export class UpsertClientResolver {
  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: false
  })
  async upsertClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertClientArgs): Promise<Client> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: AggregateClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientOrderByInput } from \\"../../../inputs/ClientOrderByInput\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class AggregateClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;

  @TypeGraphQL.Field(_type => [ClientOrderByInput], {
    nullable: true
  })
  orderBy?: ClientOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, {
    nullable: true
  })
  cursor?: ClientWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: CreateClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientCreateInput } from \\"../../../inputs/ClientCreateInput\\";

@TypeGraphQL.ArgsType()
export class CreateClientArgs {
  @TypeGraphQL.Field(_type => ClientCreateInput, {
    nullable: false
  })
  data!: ClientCreateInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: CreateManyClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientCreateManyInput } from \\"../../../inputs/ClientCreateManyInput\\";

@TypeGraphQL.ArgsType()
export class CreateManyClientArgs {
  @TypeGraphQL.Field(_type => [ClientCreateManyInput], {
    nullable: false
  })
  data!: ClientCreateManyInput[];

  @TypeGraphQL.Field(_type => Boolean, {
    nullable: true
  })
  skipDuplicates?: boolean | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: DeleteClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class DeleteClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, {
    nullable: false
  })
  where!: ClientWhereUniqueInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: DeleteManyClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";

@TypeGraphQL.ArgsType()
export class DeleteManyClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: FindFirstClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientOrderByInput } from \\"../../../inputs/ClientOrderByInput\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";
import { ClientScalarFieldEnum } from \\"../../../../enums/ClientScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindFirstClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;

  @TypeGraphQL.Field(_type => [ClientOrderByInput], {
    nullable: true
  })
  orderBy?: ClientOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, {
    nullable: true
  })
  cursor?: ClientWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [ClientScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: FindManyClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientOrderByInput } from \\"../../../inputs/ClientOrderByInput\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";
import { ClientScalarFieldEnum } from \\"../../../../enums/ClientScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindManyClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;

  @TypeGraphQL.Field(_type => [ClientOrderByInput], {
    nullable: true
  })
  orderBy?: ClientOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, {
    nullable: true
  })
  cursor?: ClientWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [ClientScalarFieldEnum], {
    nullable: true
  })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: FindUniqueClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class FindUniqueClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, {
    nullable: false
  })
  where!: ClientWhereUniqueInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: GroupByClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientOrderByInput } from \\"../../../inputs/ClientOrderByInput\\";
import { ClientScalarWhereWithAggregatesInput } from \\"../../../inputs/ClientScalarWhereWithAggregatesInput\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";
import { ClientScalarFieldEnum } from \\"../../../../enums/ClientScalarFieldEnum\\";

@TypeGraphQL.ArgsType()
export class GroupByClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;

  @TypeGraphQL.Field(_type => [ClientOrderByInput], {
    nullable: true
  })
  orderBy?: ClientOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => [ClientScalarFieldEnum], {
    nullable: false
  })
  by!: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\">;

  @TypeGraphQL.Field(_type => ClientScalarWhereWithAggregatesInput, {
    nullable: true
  })
  having?: ClientScalarWhereWithAggregatesInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: true
  })
  skip?: number | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: Index 1`] = `
"export { AggregateClientArgs } from \\"./AggregateClientArgs\\";
export { CreateClientArgs } from \\"./CreateClientArgs\\";
export { CreateManyClientArgs } from \\"./CreateManyClientArgs\\";
export { DeleteClientArgs } from \\"./DeleteClientArgs\\";
export { DeleteManyClientArgs } from \\"./DeleteManyClientArgs\\";
export { FindFirstClientArgs } from \\"./FindFirstClientArgs\\";
export { FindManyClientArgs } from \\"./FindManyClientArgs\\";
export { FindUniqueClientArgs } from \\"./FindUniqueClientArgs\\";
export { GroupByClientArgs } from \\"./GroupByClientArgs\\";
export { UpdateClientArgs } from \\"./UpdateClientArgs\\";
export { UpdateManyClientArgs } from \\"./UpdateManyClientArgs\\";
export { UpsertClientArgs } from \\"./UpsertClientArgs\\";
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: UpdateClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientUpdateInput } from \\"../../../inputs/ClientUpdateInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpdateClientArgs {
  @TypeGraphQL.Field(_type => ClientUpdateInput, {
    nullable: false
  })
  data!: ClientUpdateInput;

  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, {
    nullable: false
  })
  where!: ClientWhereUniqueInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: UpdateManyClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientUpdateManyMutationInput } from \\"../../../inputs/ClientUpdateManyMutationInput\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";

@TypeGraphQL.ArgsType()
export class UpdateManyClientArgs {
  @TypeGraphQL.Field(_type => ClientUpdateManyMutationInput, {
    nullable: false
  })
  data!: ClientUpdateManyMutationInput;

  @TypeGraphQL.Field(_type => ClientWhereInput, {
    nullable: true
  })
  where?: ClientWhereInput | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: UpsertClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { ClientCreateInput } from \\"../../../inputs/ClientCreateInput\\";
import { ClientUpdateInput } from \\"../../../inputs/ClientUpdateInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpsertClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, {
    nullable: false
  })
  where!: ClientWhereUniqueInput;

  @TypeGraphQL.Field(_type => ClientCreateInput, {
    nullable: false
  })
  create!: ClientCreateInput;

  @TypeGraphQL.Field(_type => ClientUpdateInput, {
    nullable: false
  })
  update!: ClientUpdateInput;
}
"
`;

exports[`crud when model is renamed should properly generate resolver class for single prisma model: ClientCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateClientArgs } from \\"./args/AggregateClientArgs\\";
import { CreateClientArgs } from \\"./args/CreateClientArgs\\";
import { CreateManyClientArgs } from \\"./args/CreateManyClientArgs\\";
import { DeleteClientArgs } from \\"./args/DeleteClientArgs\\";
import { DeleteManyClientArgs } from \\"./args/DeleteManyClientArgs\\";
import { FindFirstClientArgs } from \\"./args/FindFirstClientArgs\\";
import { FindManyClientArgs } from \\"./args/FindManyClientArgs\\";
import { FindUniqueClientArgs } from \\"./args/FindUniqueClientArgs\\";
import { GroupByClientArgs } from \\"./args/GroupByClientArgs\\";
import { UpdateClientArgs } from \\"./args/UpdateClientArgs\\";
import { UpdateManyClientArgs } from \\"./args/UpdateManyClientArgs\\";
import { UpsertClientArgs } from \\"./args/UpsertClientArgs\\";
import { transformFields, getPrismaFromContext, transformCountFieldIntoSelectRelationsCount } from \\"../../../helpers\\";
import { Client } from \\"../../../models/Client\\";
import { AffectedRowsOutput } from \\"../../outputs/AffectedRowsOutput\\";
import { AggregateClient } from \\"../../outputs/AggregateClient\\";
import { ClientGroupBy } from \\"../../outputs/ClientGroupBy\\";

@TypeGraphQL.Resolver(_of => Client)
export class ClientCrudResolver {
  @TypeGraphQL.Query(_returns => Client, {
    nullable: true
  })
  async findUniqueClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindUniqueClientArgs): Promise<Client | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findUnique({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => Client, {
    nullable: true
  })
  async findFirstClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindFirstClientArgs): Promise<Client | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findFirst({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => [Client], {
    nullable: false
  })
  async findManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: FindManyClientArgs): Promise<Client[]> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.findMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: false
  })
  async createClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateClientArgs): Promise<Client> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.create({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async createManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: CreateManyClientArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.createMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: true
  })
  async deleteClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteClientArgs): Promise<Client | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.delete({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: true
  })
  async updateClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateClientArgs): Promise<Client | null> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.update({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async deleteManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: DeleteManyClientArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.deleteMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => AffectedRowsOutput, {
    nullable: false
  })
  async updateManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpdateManyClientArgs): Promise<AffectedRowsOutput> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.updateMany({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: false
  })
  async upsertClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: UpsertClientArgs): Promise<Client> {
    const { _count } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.upsert({
      ...args,
      ...(_count && transformCountFieldIntoSelectRelationsCount(_count)),
    });
  }

  @TypeGraphQL.Query(_returns => AggregateClient, {
    nullable: false
  })
  async aggregateClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateClientArgs): Promise<AggregateClient> {
    return getPrismaFromContext(ctx).user.aggregate({
      ...args,
      ...transformFields(graphqlFields(info as any)),
    });
  }

  @TypeGraphQL.Query(_returns => [ClientGroupBy], {
    nullable: false
  })
  async groupByClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: GroupByClientArgs): Promise<ClientGroupBy[]> {
    const { _count, _avg, _sum, _min, _max } = transformFields(
      graphqlFields(info as any)
    );
    return getPrismaFromContext(ctx).user.groupBy({
      ...args,
      ...Object.fromEntries(
        Object.entries({ _count, _avg, _sum, _min, _max }).filter(([_, v]) => v != null)
      ),
    });
  }
}
"
`;

exports[`crud when useUncheckedScalarInputs mode is enabled should properly generate create and update args classes: CreateUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUncheckedCreateInput } from \\"../../../inputs/UserUncheckedCreateInput\\";

@TypeGraphQL.ArgsType()
export class CreateUserArgs {
  @TypeGraphQL.Field(_type => UserUncheckedCreateInput, {
    nullable: false
  })
  data!: UserUncheckedCreateInput;
}
"
`;

exports[`crud when useUncheckedScalarInputs mode is enabled should properly generate create and update args classes: UpdateManyUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUncheckedUpdateManyInput } from \\"../../../inputs/UserUncheckedUpdateManyInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";

@TypeGraphQL.ArgsType()
export class UpdateManyUserArgs {
  @TypeGraphQL.Field(_type => UserUncheckedUpdateManyInput, {
    nullable: false
  })
  data!: UserUncheckedUpdateManyInput;

  @TypeGraphQL.Field(_type => UserWhereInput, {
    nullable: true
  })
  where?: UserWhereInput | undefined;
}
"
`;

exports[`crud when useUncheckedScalarInputs mode is enabled should properly generate create and update args classes: UpdateUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUncheckedUpdateInput } from \\"../../../inputs/UserUncheckedUpdateInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpdateUserArgs {
  @TypeGraphQL.Field(_type => UserUncheckedUpdateInput, {
    nullable: false
  })
  data!: UserUncheckedUpdateInput;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud when useUncheckedScalarInputs mode is enabled should properly generate create and update args classes: UpsertUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import * as GraphQLScalars from \\"graphql-scalars\\";
import { UserUncheckedCreateInput } from \\"../../../inputs/UserUncheckedCreateInput\\";
import { UserUncheckedUpdateInput } from \\"../../../inputs/UserUncheckedUpdateInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpsertUserArgs {
  @TypeGraphQL.Field(_type => UserWhereUniqueInput, {
    nullable: false
  })
  where!: UserWhereUniqueInput;

  @TypeGraphQL.Field(_type => UserUncheckedCreateInput, {
    nullable: false
  })
  create!: UserUncheckedCreateInput;

  @TypeGraphQL.Field(_type => UserUncheckedUpdateInput, {
    nullable: false
  })
  update!: UserUncheckedUpdateInput;
}
"
`;
